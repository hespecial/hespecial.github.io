<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/Coding/hello-world/</url>
    <content><![CDATA[<div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 面试题</title>
    <url>/Interview/go-interview/</url>
    <content><![CDATA[<h1 id="Go基础"><a href="#Go基础" class="headerlink" title="Go基础"></a>Go基础</h1><h2 id="golang的特点和优势"><a href="#golang的特点和优势" class="headerlink" title="golang的特点和优势"></a>golang的特点和优势</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>语法简单</li><li>天然支持高并发</li><li>内置垃圾回收</li></ul>
              </div>
            </details>

<h2 id="golang和java对比"><a href="#golang和java对比" class="headerlink" title="golang和java对比"></a>golang和java对比</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>应用方面</strong><ul><li>Java广泛应用于大型企业应用、Android应用、大规模分布式系统和企业级应用。</li><li>Go适用于构建高性能、高并发的后端服务、网络应用、云服务以及分布式系统。</li></ul></li><li><strong>并发方面</strong><ul><li>Java通过线程和锁来处理并发。</li><li>Go语言并发特性的核心是goroutine和channel。</li></ul></li><li><strong>语言设计方面</strong><ul><li>Java是一门功能丰富、面向对象的语言，支持面向对象编程、泛型等高级特性。</li><li>Go语言的设计注重简洁和清晰，具有简单的语法和类型系统，它摒弃了一些复杂的特性，强调代码的可读性。</li></ul></li></ul>
              </div>
            </details>

<h2 id="golang数据类型"><a href="#golang数据类型" class="headerlink" title="golang数据类型"></a>golang数据类型</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>基础类型</strong><ul><li>布尔型 bool</li><li>整形 int</li><li>浮点型 float</li><li>字符串型 string</li><li>复数类型 complex</li><li>错误类型 error</li></ul></li><li><strong>复合类型</strong><ul><li>指针 pointer</li><li>数组 array</li><li>切片 slice</li><li>映射 map</li><li>通道 channel</li><li>结构体 struct</li><li>接口 interface</li><li>函数 function</li></ul></li></ul>
              </div>
            </details>

<h2 id="golang的引用类型包括哪些"><a href="#golang的引用类型包括哪些" class="headerlink" title="golang的引用类型包括哪些"></a>golang的引用类型包括哪些</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>slice</li><li>map</li><li>channel</li><li><strong>interface</strong></li></ul>
              </div>
            </details>

<h2 id="new和make的区别"><a href="#new和make的区别" class="headerlink" title="new和make的区别"></a>new和make的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>共同点</strong><ul><li>给变量分配内存&#x2F;进行初始化</li></ul></li><li><strong>不同点</strong><ul><li><strong>返回类型不同</strong><ul><li>new返回该类型的指针</li><li>make返回该类型本身</li></ul></li><li><strong>作用类型不同</strong><ul><li>new可以作用于所有类型</li><li>make只能作用于slice、map、channel</li></ul></li><li><strong>初始化方式不同</strong><ul><li>new是直接将指针所指向的内存空间清零</li><li>make可以根据变量类型来进行初始化</li></ul></li></ul></li></ul>
              </div>
            </details>

<h2 id="string和-byte的区别"><a href="#string和-byte的区别" class="headerlink" title="string和[]byte的区别"></a>string和[]byte的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p><strong>不可变性</strong></p><ul><li><p>string是不可变的数据类型，一旦创建就不能被修改。任何修改string的操作都会产生一个新的 string，而原始的string保持不变。</p></li><li><p>[]byte是可变的切片，可以通过索引直接修改切片中的元素。</p></li></ul></li><li><p><strong>内存分配</strong></p><ul><li><p>string是一个不可变的视图，底层数据是只读的，string的内存分配和释放由runtime管理</p></li><li><p>[]byte是一个可变的切片，底层数据是可以修改的，[]byte的内存管理由程序员负责</p></li></ul></li><li><p><strong>应用场景</strong></p><ul><li><p>如果需要频繁地修改字符串内容，或者处理二进制数据，使用[]byte 更为合适</p></li><li><p>如果字符串内容基本保持不变并且主要处理文本数据，那么使用 string 更为方便</p></li></ul></li></ul>
              </div>
            </details>

<h2 id="byte和rune的区别"><a href="#byte和rune的区别" class="headerlink" title="byte和rune的区别"></a>byte和rune的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>byte表示字节，是uint8的别名，rune表示字符，是int32的别名</li><li>byte表示ASCII码字符，rune表示Unicode字符</li><li>在遍历字符串时，如果字符串含有中文，需要使用rune</li></ul>
              </div>
            </details>

<h2 id="函数返回局部变量的指针是否安全"><a href="#函数返回局部变量的指针是否安全" class="headerlink" title="函数返回局部变量的指针是否安全"></a>函数返回局部变量的指针是否安全</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <p>和c&#x2F;cpp不同，由于go语言会进行内存逃逸分析，go语言中返回局部变量的指针是被允许的</p>
              </div>
            </details>

<h2 id="for-range时k、v的地址是否发生变化"><a href="#for-range时k、v的地址是否发生变化" class="headerlink" title="for range时k、v的地址是否发生变化"></a>for range时k、v的地址是否发生变化</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <p>不会</p>
              </div>
            </details>

<h2 id="关于defer"><a href="#关于defer" class="headerlink" title="关于defer"></a>关于defer</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>作用</strong><ul><li>起延迟执行的作用，可以用来进行资源释放和收尾工作</li></ul></li><li><strong>特点</strong><ul><li>和栈一样后进先出，先出现的defer后执行</li></ul></li><li><strong>使用场景</strong><ul><li>释放锁</li><li>关闭文件</li><li>配合recover捕获panic</li></ul></li></ul><blockquote><p><em><strong>Tip</strong></em></p><ul><li>defer后面跟有参函数时会直接在defer声明处进行参数传递</li><li>defer在retrun后执行，返回值为无名返回值时，返回值结果不会被修改；但是当返回值类型为有名返回值或指针时，返回值结果可能被修改</li></ul></blockquote>
              </div>
            </details>

<h2 id="golang参数传递"><a href="#golang参数传递" class="headerlink" title="golang参数传递"></a>golang参数传递</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>golang中所有传参都是值传递，即传入的是实际参数的副本</li><li>所以传递引用类型（如slice、map、channel）也是值传递，只是副本和实际参数引用的底层数据是相同的。比如传入切片，副本切片引用的是和原切片相同的底层数组，所以对副本进行修改操作时原切片也会受到影响</li></ul>
              </div>
            </details>

<h2 id="golang面向对象"><a href="#golang面向对象" class="headerlink" title="golang面向对象"></a>golang面向对象</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>封装</strong><ul><li>首字母大写的字段和方法是公有的，可以被其他包访问</li><li>首字母小写的字段和方法是私有的，只能在当前包中使用</li></ul></li><li><strong>继承</strong><ul><li>go使用结构体嵌套的方式实现继承，嵌入的匿名结构体称为嵌入类型</li><li>具有字段提升的特性，可以把父类型的字段和方法注入到子类型中去</li><li>另外go语言支持多重继承</li></ul></li><li><strong>多态</strong><ul><li>go通过interface来实现多态</li><li>一个类型的实例可以赋值给它所实现的任意接口</li></ul></li></ul>
              </div>
            </details>

<h2 id="如何高效拼接字符串"><a href="#如何高效拼接字符串" class="headerlink" title="如何高效拼接字符串"></a>如何高效拼接字符串</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>方式</strong><ul><li><code>+</code></li><li><code>fmt.Sprintf()</code></li><li><code>strings.Builder()</code></li><li><code>bytes.Buffer()</code></li><li><code>strings.Join()</code></li></ul></li><li><strong>性能</strong><ul><li><code>strings.Join()</code> ≈ <code>strings.Builder()</code> &gt; <code>bytes.Buffer()</code> &gt;<code>+</code>+ &gt; <code>fmt.Sprintf()</code></li></ul></li></ul>
              </div>
            </details>

<h2 id="空struct-的作用"><a href="#空struct-的作用" class="headerlink" title="空struct{}的作用"></a>空struct{}的作用</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>作用</strong><ul><li>因为空struct{}的实例（struct{}{}）本身不占用内存空间，所以可以用来当作占位符使用</li></ul></li><li><strong>使用场景</strong><ul><li>go语言没有set类型，可以利用map来实现，map的key为需要存储的元素，value可以使用stuct{}{}</li><li>协程之间使用channel进行通信时，如果不在乎通信的内容，仅仅只是接受一个信号，那么可以使用struct{}{}</li></ul></li></ul>
              </div>
            </details>

<h2 id="int和int32是同一个概念吗"><a href="#int和int32是同一个概念吗" class="headerlink" title="int和int32是同一个概念吗"></a>int和int32是同一个概念吗</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>int32仅仅表示32位的无符号整数</li><li>int底层基于操作系统实现，其大小取决于操作系统的位数<ul><li>int在32位系统中的int和int32是相同的，在64位系统则表示64位整数</li><li>int基于操作系统的底层实现是golang能够在不同平台运行的基础</li></ul></li></ul>
              </div>
            </details>

<h2 id="golang程序初始化执行顺序"><a href="#golang程序初始化执行顺序" class="headerlink" title="golang程序初始化执行顺序"></a>golang程序初始化执行顺序</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>import –&gt; const –&gt; var –&gt;init()–&gt;main()</li><li>单个源文件存在多个init时，从上至下依次执行</li><li>相同包下多个源文件都存在init时，根据文件名的字典序执行</li><li>import导包过程中<ul><li>有依赖关系：递归执行上述流程</li><li>无依赖关系：按照导包顺序依次执行</li></ul></li></ul>
              </div>
            </details>

<h2 id="struct能否比较"><a href="#struct能否比较" class="headerlink" title="struct能否比较"></a>struct能否比较</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>不同类型的struct不能比较</li><li>相同类型的struct分为两种情况<ul><li>若struct内所有成员均可比较，则该struct的不同实例可以比较</li><li>反之，如含有slice、map、function，则不能比较</li></ul></li></ul>
              </div>
            </details>

<h2 id="interface能否比较"><a href="#interface能否比较" class="headerlink" title="interface能否比较"></a>interface能否比较</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>可以进行比较</li><li>只在两种情况下相等：<ul><li>两个interface均等于nil</li><li>两个interface内部的类型和值都相等</li></ul></li></ul>
              </div>
            </details>

<h2 id="两个nil可能不相等吗"><a href="#两个nil可能不相等吗" class="headerlink" title="两个nil可能不相等吗"></a>两个nil可能不相等吗</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>只有在类型相同时两个nil才相等</li></ul><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p1, p2 *<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> p3 *<span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p1==p3 类型不同，编译不通过</span></span><br><span class="line">fmt.Println(p1 == <span class="literal">nil</span>, p2 == <span class="literal">nil</span>, p1 == p2) <span class="comment">// true true true</span></span><br><span class="line">fmt.Println(a == <span class="literal">nil</span>, p == <span class="literal">nil</span>, a == p) <span class="comment">// true true false</span></span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<h2 id="值类型T和指针类型-T可以互相调用方法吗"><a href="#值类型T和指针类型-T可以互相调用方法吗" class="headerlink" title="值类型T和指针类型*T可以互相调用方法吗"></a>值类型T和指针类型*T可以互相调用方法吗</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>使用值类型T调用*T的方法，只有当此T是可寻址的情况下才可以。比如常量就无法寻址，也就无法对其进行取地址操作。</li><li>反过来，*T只有在不是空指针的情况下才可以调用值类型T的方法。</li></ul><div class="tabs" id="tab-first"><ul class="nav-tabs"><li class="tab active"><a class="#first-1">T调用*T的方法</a></li><li class="tab"><a class="#first-2">*T调用T的方法</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-1"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myInt)</span></span> f() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ⬇️会报错，因为3无法寻址</span></span><br><span class="line">	<span class="comment">// myInt(3).f()</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a myInt = <span class="number">3</span></span><br><span class="line">	a.f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="first-2"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*test)</span></span> f1() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;f1 ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(test)</span></span> f2() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;f2 ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> t1 *T</span><br><span class="line">	t1.f1()</span><br><span class="line">    <span class="comment">// ⬇️ *T调用T的方法时会自动解引用，而*T解引用后是nil，nil调用方法会报错</span></span><br><span class="line">	<span class="comment">// t1.f2()</span></span><br><span class="line">	<span class="keyword">var</span> t2 T</span><br><span class="line">	t2.f1()</span><br><span class="line">	t2.f2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div></div>
              </div>
            </details>

<h2 id="值接收者和指针接收者实现接口的区别"><a href="#值接收者和指针接收者实现接口的区别" class="headerlink" title="值接收者和指针接收者实现接口的区别"></a>值接收者和指针接收者实现接口的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>使用值接收者实现接口之后，不管是值类型的变量还是指针类型的变量都可以赋值给接口变量，因为对一个不为空的对象进行解引用总是合法的</li><li>但使用指针接收者实现接口后，只能将指针类型的变量赋值给接口变量，如果使用值类型进行赋值，在接口转换过程中，该值类型可能无法被取地址，会导致无法调用指针方法，因此在编译阶段就杜绝了这种行为</li></ul>
              </div>
            </details>

<h2 id="v、-v、-v的区别"><a href="#v、-v、-v的区别" class="headerlink" title="%v、%+v、%#v的区别"></a>%v、%+v、%#v的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>%v 只输出所有的值</li><li>%+v 先输出字段类型，再输出该字段的值</li><li>%#v 先输出结构体名字值，再输出结构体（字段类型+字段的值）</li></ul><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := &amp;student&#123;<span class="string">&quot;luxiao&quot;</span>, <span class="number">123456</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%%v的方式  = %v\n&quot;</span>, s)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%%+v的方式 = %+v\n&quot;</span>, s)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%%#v的方式 = %#v\n&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// %v的方式  = &amp;&#123;luxiao 123456&#125;</span></span><br><span class="line"><span class="comment">// %+v的方式 = &amp;&#123;name:&quot;luxiao&quot; id:123456&#125;</span></span><br><span class="line"><span class="comment">// %#v的方式 = &amp;main.student&#123;name:&quot;luxiao&quot;, id:123456&#125;</span></span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<h2 id="指针的作用"><a href="#指针的作用" class="headerlink" title="指针的作用"></a>指针的作用</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>函数传参或者方法中传递接收者时，如果要对原值进行修改，一般传递指针参数</li><li>如果结构体比较大的话，使用指针可以节省空间并提高效率</li></ul>
              </div>
            </details>

<h2 id="介绍一下context"><a href="#介绍一下context" class="headerlink" title="介绍一下context"></a>介绍一下context</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p>context用来管理上下文，具体有如下作用</p><ul><li><p>传递取消信号：可以用来传递取消信号，让一个正在执行的函数知道它应该提前终止</p></li><li><p>超时控制：可以设定一个超时时间，自动取消超过执行时间的操作</p></li><li><p>截止时间：与超时类似，但是是设定一个绝对时间点，而不是时间段</p></li><li><p>值传递：可以安全地在请求的上下文中传递数据，避免了使用全局变量或者参数列表不断增长</p></li></ul></li><li><p>Context是一个接口，该接口定义了四个需要实现的方法</p><ul><li><p>Deadline方法需要返回当前Context被取消的时间，也就是完成工作的截止时间（deadline）</p></li><li><p>Done方法需要返回一个Channel，这个Channel会在当前工作完成或者上下文被取消之后关闭，多次调用Done方法会返回同一个Channel</p></li><li><p>Err方法会返回当前Context结束的原因，它只会在Done返回的Channel被关闭时才会返回非空的值；</p></li><li><p>Value方法会从Context中返回键对应的值</p></li></ul></li><li><p>可以使用Background或Todo创建顶层上下文，使用WithCancel、WithDeadline、WithTimeout或WithValue创建派生上下文</p></li><li><p>当一个上下文被取消时，它派生的所有上下文也被取消</p></li></ul><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<h1 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h1><h2 id="数组和切片的区别"><a href="#数组和切片的区别" class="headerlink" title="数组和切片的区别"></a>数组和切片的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>长度是否可变</strong><ul><li>数组是一个长度固定的数据类型，其长度在定义时就已经确定，不能动态改变</li><li>切片是一个长度可变的数据类型，其长度在定义时可以为空，也可以指定一个初始长度（和容量），后续可以自动扩容</li></ul></li><li><strong>内存分配时机</strong><ul><li>数组在编译时期确定内存分配</li><li>切片在运行时期动态分配内存</li></ul></li><li><strong>参数传递方式</strong><ul><li>本质上数组和切片都是值传递</li><li>当数组作为函数参数时，函数操作的是数组的一个副本，不会影响原始数组</li><li>当切片作为函数参数时，函数操作的是切片中底层数组的引用，会影响原始切片，<strong>但是存在特例</strong>，当切片在函数中进行扩容时，会导致这个切片的底层指针指向新的底层数组，不再和原切片共享一个底层数组，发生扩容后函数修改切片不会对原切片造成影响</li></ul></li></ul>
              </div>
            </details>

<h2 id="slice底层原理"><a href="#slice底层原理" class="headerlink" title="slice底层原理"></a>slice底层原理</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p><strong>组成</strong></p><ul><li>指针、长度和容量。指针指向底层数组，长度代表slice当前的长度，容量代表底层数组的长度</li></ul></li><li><p><strong>append追加原则</strong></p><ul><li>假如slice容量够用，则追加新元素进去，返回原来的slice</li><li>若原容量不够，则slice 先扩容，扩容之后得到新的slice，将元素追加进新的slice，最后返回新的slice</li></ul></li><li><p><strong>扩容规则</strong></p><ul><li><p><strong>1.18之前</strong>：当切片容量小于1024时，扩容为原来的2倍，这样可以避免频繁扩容；当切片容量大于等于1024时，扩容为原来的1.25倍，这样可以避免内存浪费；如果扩容后还不够，则直接使用需要的容量</p></li><li><p>**1.18及之后：**当切片容量小于256时，扩容为原来的两倍；当切片容量大于等于256时，按照公式进行扩容<code>newcap+=(newcap+3*256)/4</code>；如果扩容后还不够，则直接使用需要的容量</p></li><li><p>改版之后扩容过程相对于原来更为平缓</p></li></ul></li></ul>
              </div>
            </details>

<h2 id="切片的深浅拷贝"><a href="#切片的深浅拷贝" class="headerlink" title="切片的深浅拷贝"></a>切片的深浅拷贝</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>深浅拷贝都是进行复制，本质区别就是复制出来的对象与原对象的底层数组指针是否会指向同一个地址<ul><li>深拷贝会在内存中重新开辟一块内存，再让底层指针指向这片新的内存</li><li>浅拷贝会和原切片共享同一个底层数组</li></ul></li><li>具体应用<ul><li>使用**&#x3D;操作符<strong>和</strong>[ : ]下标**的方式拷贝切片是浅拷贝</li><li>使用<strong>copy()函数</strong>复制是深拷贝</li></ul></li></ul>
              </div>
            </details>

<h2 id="零切片、nil切片、空切片"><a href="#零切片、nil切片、空切片" class="headerlink" title="零切片、nil切片、空切片"></a>零切片、nil切片、空切片</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>零切片</strong><ul><li>切片元素为相应的零值的切片</li></ul></li><li><strong>nil切片</strong><ul><li>长度和容量都为0</li><li>和nil比较的结果为true</li></ul></li><li><strong>空切片</strong><ul><li>长度和容量也都为0</li><li>和nil的比较结果为false，因为所有的空切片的底层指针都指向同一个地址</li></ul></li></ul><div class="tabs" id="tab-second"><ul class="nav-tabs"><li class="tab active"><a class="#second-1">零切片</a></li><li class="tab"><a class="#second-2">nil切片</a></li><li class="tab"><a class="#second-3">空切片</a></li></ul><div class="tab-content"><div class="tab-pane active" id="second-1"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">5</span>) <span class="comment">// 0 0 0 0 0</span></span><br><span class="line">slice := <span class="built_in">make</span>([]*<span class="type">int</span>,<span class="number">5</span>) <span class="comment">// nil nil nil nil nil</span></span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="second-2"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> slice = *<span class="built_in">new</span>([]<span class="type">int</span>)</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="second-3"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div></div></div></div>
              </div>
            </details>

<h2 id="判断两个切片是否相等"><a href="#判断两个切片是否相等" class="headerlink" title="判断两个切片是否相等"></a>判断两个切片是否相等</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>可以调用reflect包下的DeepEqual()，但并不建议这么做，因为其底层使用了反射进行判断，比较影响性能</li><li>在知道切片类型的情况下，自己实现循环比较的性能更佳</li></ul>
              </div>
            </details>

<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="map常识"><a href="#map常识" class="headerlink" title="map常识"></a>map常识</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>map基于key的维度进行去重</li><li>map的遍历是无序的，若想要顺序遍历，则需要先对key排序，再按照key的顺序遍历map</li><li>对map进行读、写、删的操作的时间复杂度为O(1)</li><li>key必须为可比较类型，go语言中slice、map、func三种类型不可比较</li><li>map不是并发安全的，读map时可以并发读，但是写map时并发读写都不被允许。若要实现map的并发读写，有两种方式<ul><li>map+互斥锁&#x2F;读写锁</li><li>使用go自带的并发安全的sync.Map</li></ul></li></ul>
              </div>
            </details>

<h2 id="map为什么是无序的"><a href="#map为什么是无序的" class="headerlink" title="map为什么是无序的"></a>map为什么是无序的</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>其一，map在进行扩容的过程中可能打乱原始键值对的顺序</li><li>其二，官方在for-range遍历map时做了随机播种</li></ul>
              </div>
            </details>

<h2 id="map中删除一个key，它的内存会释放么"><a href="#map中删除一个key，它的内存会释放么" class="headerlink" title="map中删除一个key，它的内存会释放么"></a>map中删除一个key，它的内存会释放么</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>如果删除的元素是值类型，如int，float，bool，string以及数组和struct，map的内存不会自动释放</li><li>如果删除的元素是引用类型，如指针，slice，map，chan等，map的内存会自动释放，但释放的内存是子元素应用类型的内存占用</li><li>将map设置为nil后，内存被回收</li></ul>
              </div>
            </details>

<h2 id="map底层结构"><a href="#map底层结构" class="headerlink" title="map底层结构"></a>map底层结构</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>map在底层算法上通过哈希表实现</li><li>每个map都是一个指针，指向hmap结构体，hmap主要包含一个桶数组的指针（buckets），以及维护这个桶数组所需的一些字段</li><li>桶数组中每个元素都是一个bmap结构体，也就是所谓的桶，每个桶固定可以存放8个kv键值对以及一个指向下一个溢出桶的指针</li><li>每个kv键值对数据包含tophash(key的高8位哈希值)、key、val三部分</li></ul><div class="tabs" id="tab-third"><ul class="nav-tabs"><li class="tab active"><a class="#third-1">数据结构</a></li><li class="tab"><a class="#third-2">图示</a></li></ul><div class="tab-content"><div class="tab-pane active" id="third-1"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count     <span class="type">int</span>    <span class="comment">// map中kv键值对总数</span></span><br><span class="line">	flags     <span class="type">uint8</span>  <span class="comment">// 状态标志，标识出map是否被并发读写</span></span><br><span class="line">	B         <span class="type">uint8</span>  <span class="comment">// 桶数组长度的指数，桶数组长度为2^B</span></span><br><span class="line">	noverflow <span class="type">uint16</span> <span class="comment">// 溢出桶的数量</span></span><br><span class="line">	hash0     <span class="type">uint32</span> <span class="comment">// 随机因子，生成key的hash值时会用到</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// 桶数组的指针</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// 扩容过程中旧的桶数组</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span>        <span class="comment">// 扩容进度标识，小于此地址的buckets代表已搬迁完成。</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// 预申请的溢出桶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="third-2"><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/map-structure.png"
                      alt="map structure"
                ></p></div></div></div>
              </div>
            </details>

<h2 id="map读写过程"><a href="#map读写过程" class="headerlink" title="map读写过程"></a>map读写过程</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p><strong>读流程</strong></p><ol><li>根据key取hash值</li><li>根据hash值以及B对桶数组长度取模，确定所在的桶</li><li>沿着桶链表依次遍历各个桶内的kv键值对</li><li>命中相同的key则返回value，若key不存在则返回零值</li></ol></li><li><p><strong>写流程</strong></p><ul><li>基本一致，只是如果发现map处在扩容过程中则会帮助推进渐进式扩容</li></ul></li></ul><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/map-process.png"
                      alt="map process"
                ></p>
              </div>
            </details>

<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>产生原因</strong><ul><li>由于输入域（key）无穷大，输出域（hash 值）有限，因此必然存在不同 key 映射到相同 hash 值的情况，称之为 hash 冲突</li><li>再者，hash 值会对桶数组长度取模，因此不同 hash 值可能被打到同一个桶中</li></ul></li><li><strong>常见解决办法</strong><ul><li><strong>拉链法</strong><ul><li>将命中同一个位置的元素通过链表的形式进行链接</li><li>无需预先为元素分配内存，便于动态扩展</li></ul></li><li><strong>开放寻址法</strong><ul><li>在插入新条目时，会基于一定的探测策略持续寻找，直到找到一个可用于存放数据的空位为止</li><li>无需额外的指针用于链接元素；内存地址完全连续，可以基于局部性原理，充分利用 CPU 高速缓存</li></ul></li></ul></li><li><strong>go语言的处理方法</strong>（结合拉链法和开放寻址法两种思路）<ul><li>当 key 命中一个桶时，首先根据开放寻址法，在桶的 8 个位置中寻找空位进行插入</li><li>倘若桶的 8 个位置都已被占满，则基于桶的溢出桶指针，找到下一个桶，重复第上一步</li><li>倘若遍历到链表尾部，仍未找到空位，则基于拉链法，在桶链表尾部续接新桶，并插入kv对</li></ul></li></ul>
              </div>
            </details>

<h2 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>渐进式扩容</strong><ul><li>每次写操作都会帮助推进扩容的过程，避免因为一次性的全量数据迁移引发性能抖动</li></ul></li><li><strong>扩容类型</strong><ul><li><strong>增量扩容</strong><ul><li>扩容后，桶数组的长度增长为原长度的 2 倍</li><li>目的是降低每个桶中 key-value 对的数量，优化 map 操作的时间复杂度</li></ul></li><li><strong>等量扩容</strong><ul><li>扩容后，桶数组的长度和之前保持一致，但是溢出桶的数量会下降</li><li>目的是提高桶主体结构的数据填充率，减少溢出桶数量，避免发生内存泄漏</li></ul></li></ul></li><li><strong>扩容时机</strong><ul><li><strong>装载因子超出阈值6.5</strong><ul><li>map 中 key-value 对的数量超过 8 个，且大于桶数组长度的 6.5 倍，则进入增量扩容</li></ul></li><li><strong>溢出桶数量过多</strong><ul><li>若溢出桶的数量大于 2^B 个（即桶数组的长度；B 大于 15 时取15），则进入等量扩容</li></ul></li></ul></li></ul><div class="tabs" id="tab-fourth"><ul class="nav-tabs"><li class="tab active"><a class="#fourth-1">增量扩容</a></li><li class="tab"><a class="#fourth-2">等量扩容</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fourth-1"><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/map-double-incr.png"
                      alt="double incr"
                ></p></div><div class="tab-pane" id="fourth-2"><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/map-equal-incr.png"
                      alt="equal incr"
                ></p></div></div></div>
              </div>
            </details>

<h2 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ol><li>计算新的存储桶数量：当map 的元素数量达到负载因子 (load factor)的上限时，会触发扩容。新的存储桶数量通常会是当前存储桶数量的两倍。</li><li>分配新的存储桶：创建新的存储桶和散列数组，大小为新的存储桶数量</li><li>重新散列元素：遍历当前 map 的每个存储桶，将其中的元素重新散列到新的存储桶中，这个过程是渐进式的</li><li>切换到新的存储桶：将 map 的内部数据结构指向新的存储桶和散列数组，这个过程是原子的，以确保在切换期间不会影响并发访问。</li><li>释放旧的存储桶：释放的存储桶和散列数组的内存空间，避免内存泄漏</li></ol>
              </div>
            </details>

<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><h2 id="无缓冲的channel和有缓冲的channel的区别"><a href="#无缓冲的channel和有缓冲的channel的区别" class="headerlink" title="无缓冲的channel和有缓冲的channel的区别"></a>无缓冲的channel和有缓冲的channel的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p><strong>无缓冲channel是同步的，有缓冲channel是异步的</strong></p></li><li><p>对于无缓冲的channel</p><ul><li>发送方向channel发送数据，但没有接收方接受数据时，发送方阻塞</li><li>接收方从channel接收数据，但没有发送方发送数据时，接收方阻塞</li></ul></li><li><p>对于有缓冲的channel</p><ul><li><p>发送方只有在缓冲区满时阻塞</p></li><li><p>接收方只有在缓冲区空时阻塞</p></li></ul></li><li><p>无缓冲的channel其实可以看作缓冲区大小为0的channel，从这个角度看，无缓冲channel兼具了缓冲区满和缓冲区空的特点</p></li></ul>
              </div>
            </details>

<h2 id="channel的底层原理"><a href="#channel的底层原理" class="headerlink" title="channel的底层原理"></a>channel的底层原理</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p>channel的底层数据结构实际上是一个循环数组，每个channel都对应一个hchan结构体，结构体中包含一些维护这个循环数组的字段</p></li><li><p>比较重要的几个字段</p><ul><li><p>buf 指向底层循环数组，只有缓冲型的 channel 才有。</p></li><li><p>sendx，recvx 均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。</p></li><li><p>sendq，recvq 分别表示被阻塞的 goroutine的等待队列，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。</p></li><li><p>lock 用来保证每个读 channel 或写 channel 的操作都是原子的。</p></li></ul></li></ul><div class="tabs" id="tab-fifth"><ul class="nav-tabs"><li class="tab active"><a class="#fifth-1">channel数据结构</a></li><li class="tab"><a class="#fifth-2">图示</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fifth-1"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// chan 里元素数量</span></span><br><span class="line">    qcount <span class="type">uint</span></span><br><span class="line">    <span class="comment">// chan 底层循环数组的长度</span></span><br><span class="line">    dataqsiz <span class="type">uint</span></span><br><span class="line">    <span class="comment">// 指向底层循环数组的指针</span></span><br><span class="line">    <span class="comment">// 只针对有缓冲的 channel</span></span><br><span class="line">    buf unsafe.Pointer</span><br><span class="line">    <span class="comment">// chan 中元素大小</span></span><br><span class="line">    elemsize <span class="type">uint16</span></span><br><span class="line">    <span class="comment">// chan 是否被关闭的标志</span></span><br><span class="line">    closed <span class="type">uint32</span></span><br><span class="line">    <span class="comment">// chan 中元素类型</span></span><br><span class="line">    elemtype *_type  <span class="comment">// element type</span></span><br><span class="line">    <span class="comment">// 已发送元素在循环数组中的索引</span></span><br><span class="line">    sendx <span class="type">uint</span>  <span class="comment">// send index</span></span><br><span class="line">    <span class="comment">// 已接收元素在循环数组中的索引</span></span><br><span class="line">    recvx <span class="type">uint</span>  <span class="comment">// receive index</span></span><br><span class="line">    <span class="comment">// 等待接收的 goroutine 队列</span></span><br><span class="line">    recvq waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">    <span class="comment">// 等待发送的 goroutine 队列</span></span><br><span class="line">    sendq waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">    <span class="comment">// 保护 hchan 中所有字段</span></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="fifth-2"><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/channel-structure.png"
                      alt="channel structure"
                ></p></div></div></div>
              </div>
            </details>

<h2 id="channel发送和接收数据的过程"><a href="#channel发送和接收数据的过程" class="headerlink" title="channel发送和接收数据的过程"></a>channel发送和接收数据的过程</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p>goroutine向channel发送数据</p><ul><li><p>goroutine首先获取channel的锁</p></li><li><p>如果channel缓冲区未满，则直接将数写入缓冲区，并更新sendx</p></li><li><p>如果缓冲区已满，则将当前goroutine挂到sendq等待队列中，并释放锁，等到有goroutine接受数据才会被唤醒</p></li></ul></li><li><p>channel从goroutine接收数据</p><ul><li><p>goroutine首先获取channel的锁</p></li><li><p>如果channel缓冲区非空，则直接从缓冲区读取数据，并更新recvx</p></li><li><p>如果缓冲区为空，则将当前goroutine挂到recvq等待队列中，并释放锁，等到有goroutine写入数据才会被唤醒</p></li></ul></li></ul>
              </div>
            </details>

<h2 id="操作channel的情况"><a href="#操作channel的情况" class="headerlink" title="操作channel的情况"></a>操作channel的情况</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <table><thead><tr><th><strong>操作</strong></th><th align="center"><strong>nil channel</strong></th><th align="center"><strong>closed channel</strong></th><th align="center"><strong>not nil, not closed channel</strong></th></tr></thead><tbody><tr><td><strong>close</strong></td><td align="center">panic</td><td align="center">panic</td><td align="center">正常关闭</td></tr><tr><td><strong>读</strong></td><td align="center">阻塞</td><td align="center">读到对应类型的零值</td><td align="center">阻塞或正常读取数据。缓冲型 channel 为空或非缓冲型 channel 没有等待发送者时会阻塞</td></tr><tr><td><strong>写</strong></td><td align="center">阻塞</td><td align="center">panic</td><td align="center">阻塞或正常写入数据，非缓冲型 channel 没有等待接收者或缓冲型 channel buf 满时会被阻塞</td></tr></tbody></table>
              </div>
            </details>

<h1 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h1><h2 id="mutex有几种模式"><a href="#mutex有几种模式" class="headerlink" title="mutex有几种模式"></a>mutex有几种模式</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>正常模式</strong><ul><li>在正常模式下，一个尝试加锁的goroutine会先自旋几次，尝试通过原子操作获得锁，若几次自旋之后仍不能获得锁，则通过信号量排队等待。但是当锁被释放，第一个等待者被唤醒后并不会直接拥有锁，而是需要和后来者竞争，也就是那些处于自旋阶段，尚未排队等待的goroutine。这种情况下后来者更有优势，一方面，它们正在CPU上运行，自然比刚被唤醒的goroutine更有优势，另一方面处于自旋状态的goroutine可以有很多，而被唤醒的goroutine每次只有一个，所以被唤醒的goroutine有很大概率拿不到锁。这种情况下它会被重新插入到队列的头部，而不是尾部。而当一个goroutine本次加锁等待时间超过了1ms后，它会把当前Mutex从正常模式切换至“饥饿模式”。</li></ul></li><li><strong>饥饿模式</strong><ul><li>在饥饿模式下，Mutex的所有权从执行Unlock的goroutine，直接传递给等待队列头部的goroutine，后来者不会自旋，也不会尝试获得锁，即使Mutex处于Unlocked的状态。它们会直接到队列的尾部排队等待。当一个等待者获得锁之后，它会在以下两种情况时，将Mutex由饥饿模式切换回正常模式。第一种情况是它的等待时间小于1ms，也就是它刚来不久；第二种情况是它是最后一个等待者，等待队列已经空了，后面自然就没有饥饿的goroutine了。</li></ul></li></ul>
              </div>
            </details>

<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>CAS的全称为Compare And Swap，直译就是比较交换，是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值</li><li>假设包含3个参数内存位置(V)、预期原值(A)和新值(B)。V表示要更新变量的值，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程在做更新，则当前线程什么都不做，最后CAS返回当前V的真实值。CAS操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对于当前线程的干扰。</li></ul>
              </div>
            </details>

<h1 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h1><h2 id="什么是GMP"><a href="#什么是GMP" class="headerlink" title="什么是GMP"></a>什么是GMP</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p><strong>Goroutine (G)</strong></p><ul><li><p>Goroutine是Go语言中的轻量级线程，能够与其他goroutine并发执行。</p></li><li><p>与传统的线程相比，goroutine的创建和销毁成本非常低。</p></li><li><p>Goroutine由Go的运行时系统调度，不依赖于操作系统的线程调度。</p></li></ul></li><li><p><strong>Machine (M)</strong></p><ul><li><p>Machine代表操作系统的线程。</p></li><li><p>M负责执行Goroutine。</p></li></ul></li><li><p><strong>Processor (P)</strong></p><ul><li><p>Processor是一个逻辑处理器，负责Goroutine的调度。</p></li><li><p>P维护一个本地队列，其中保存了准备运行的Goroutine。</p></li><li><p>每个P都绑定到一个M上，如果绑定后的M获取不到可执行的G，那么该M就会自旋，而其他绑定不到P的M会休眠</p></li></ul></li></ul><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/gmp.jpg"
                      alt="gmp"
                ></p>
              </div>
            </details>

<h2 id="GMP的工作原理"><a href="#GMP的工作原理" class="headerlink" title="GMP的工作原理"></a>GMP的工作原理</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p>首先通过go func()创建一个Goroutine</p></li><li><p>这个创建的G会优先放入当前P的本地队列中，如果本地队列满了，则会把本地队列中一半的G和这个创建的G放入全局队列中</p></li><li><p>然后M从P的本地队列中获取一个G来执行，如果本地队列已经没有可运行的G，则会从全局队列中获取，如果全局队列中获取不到，则采取work stealing机制，从其他P的本地队列中偷取一半的G，如果偷取不到，那么该M会进入自旋状态，等待新的goroutine执行</p></li><li><p>M在执行goroutine时会遇到3种情况</p><ul><li><p>正常情况下，当前goroutine执行完成后，M上运行的goroutine会切换成G0，G0负责调度时的协程切换，G0会从P的本地队列中再获取G，然后M从G0切换到这个G，并开始运行它</p></li><li><p>如果当前goroutine运行时间超过10ms，因为是抢占式调度，M会暂停执行该goroutine，将其放回本地队列尾部，转而执行其他的goroutine</p></li><li><p>如果M执行G时发生了阻塞，那么就会采用hand off机制，M会释放当前绑定的P，然后创建一个新的M服务这个P（如果有空闲的M就直接复用），当原来的M退出阻塞状态之后，它会尝试获取之前释放的P，如果无法获取，则获取空闲的P，如果依然没有，那么挂载在这个M上的G会被标记为可运行状态，放回到全局队列中，这个M进入休眠状态</p></li></ul></li></ul>
              </div>
            </details>

<h2 id="P和-M的数量关系"><a href="#P和-M的数量关系" class="headerlink" title="P和 M的数量关系"></a>P和 M的数量关系</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>P 的数量：由 runtime 的 GOMAXPROCS 决定。</li><li>M 的数量：<ul><li>go 程序启动时，会设置 M 的最大数量，默认 10000，但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li><li>runtime&#x2F;debug 中的 SetMaxThreads 函数，可以设置 M 的最大数量。</li></ul></li><li>M的数量&gt;&#x3D;P的数量，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来</li></ul>
              </div>
            </details>

<h2 id="P和-M何时会被创建"><a href="#P和-M何时会被创建" class="headerlink" title="P和 M何时会被创建"></a>P和 M何时会被创建</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>P 何时创建<ul><li>在确定了 P 的最大数量 n 后，runtime会根据这个数量创建 n 个 P</li></ul></li><li>M 何时创建<ul><li>没有足够的 M 来关联 P 并运行其中的可运行的 G</li><li>比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。</li></ul></li></ul>
              </div>
            </details>

<h2 id="M0和G0"><a href="#M0和G0" class="headerlink" title="M0和G0"></a>M0和G0</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了</li><li>G0 是每次启动一个 M 都会创建的一个 goroutine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0</li></ul>
              </div>
            </details>

<h2 id="没有P会怎样"><a href="#没有P会怎样" class="headerlink" title="没有P会怎样"></a>没有P会怎样</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>Go语言早期的调度模型（GM模型）就是没有P的，这样的调度模型会存在一些性能问题</li><li>没有P也就没有本地队列，M想要执行和放回G都需要通过全局队列来完成，而多线程访问同一资源需要通过加锁来保证同步</li><li>创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的锁竞争</li><li>M 转移 G 会造成延迟和额外的系统负载。比如当 G1 中创建新协程的时候，M1创建了 G2，为了继续执行 G1，需要把 G2交给M2执行，也造成了很差的局部性，因为 G2 和 G1 是相关的，最好放在 M1 上执行，而不是其他的M</li></ul>
              </div>
            </details>

<h2 id="work-stealing机制为什么不需要加锁"><a href="#work-stealing机制为什么不需要加锁" class="headerlink" title="work stealing机制为什么不需要加锁"></a>work stealing机制为什么不需要加锁</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <p>P 从本地队列取 G 的这个操作，是一个 CAS 操作，它具有原子性，是由硬件直接支持的，不需要并发的竞争关系</p>
              </div>
            </details>

<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="CSP并发模型"><a href="#CSP并发模型" class="headerlink" title="CSP并发模型"></a>CSP并发模型</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>CSP（Communicating Sequential Processes，通信顺序进程），其设计理念是<strong>通过通信来共享内存，而不是通过共享内存来通信</strong></li><li>go语言的并发模型基于CSP，通过goroutine和channel来实现</li></ul>
              </div>
            </details>

<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <p>原子操作是一组不可分割的操作，用于在并发环境中安全地修改共享资源。Go语言的sync&#x2F;atomic包提供了一组原子操作函数，用于对基本数据类型（如整数）进行安全的读写，防止竞态条件。</p>
              </div>
            </details>

<h2 id="什么时候会发生阻塞"><a href="#什么时候会发生阻塞" class="headerlink" title="什么时候会发生阻塞"></a>什么时候会发生阻塞</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>系统调用<ul><li>当Goroutine执行一个阻塞的系统调用（如文件I&#x2F;O、网络I&#x2F;O等）时，它会被阻塞，直到系统调用完成。</li></ul></li><li>通道操作<ul><li>Goroutine在执行通道（channel）操作时，如发送数据到一个已满的通道或从一个空的通道接收数据，可能会发生阻塞。阻塞会持续到通道中有足够的空间或数据可用。</li></ul></li></ul>
              </div>
            </details>

<h2 id="如何处理阻塞"><a href="#如何处理阻塞" class="headerlink" title="如何处理阻塞"></a>如何处理阻塞</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>在创建通道时指定缓冲区大小，即创建⼀个缓冲通道<ul><li>当缓冲区未满时，发送数据不会阻塞</li><li>当缓冲区未空时，接收数据不会阻塞</li></ul></li><li>select 语句用于处理多个通道操作，使用default分支，可以在所有通道都阻塞的情况下执行非阻塞的操作</li><li>超时控制<ul><li>context.WithTimeOut()</li><li>time.After()</li></ul></li></ul>
              </div>
            </details>

<h2 id="如何控制goroutine的生命周期"><a href="#如何控制goroutine的生命周期" class="headerlink" title="如何控制goroutine的生命周期"></a>如何控制goroutine的生命周期</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p><strong>启动</strong></p><ul><li>使用go关键字创建一个新的goroutine</li></ul></li><li><p><strong>退出</strong></p><ul><li><p>等待退出：使用sync.WaitGroup来实现等待进程自行结束</p></li><li><p>阻塞退出：通过channel发送一个信号使阻塞状态的goroutine退出</p></li><li><p>手动退出：使用context.WithCancel()手动结束goroutine</p></li><li><p>超时退出：使用context.WithTimeOut()可以实现超时强制退出</p></li></ul></li></ul>
              </div>
            </details>

<h1 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>含义</strong><ul><li>指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光</li></ul></li><li><strong>场景</strong><ul><li>字符串&#x2F;切片截取导致内存泄漏</li><li>goroutine被长期挂住，导致该协程中的内存也无法被释放，就会造成永久性的内存泄漏。比如协程结束时协程中的channel没有关闭，导致一直阻塞，再比如协程中有死循环等等</li></ul></li><li><strong>排查方式</strong><ul><li>pprof是Go的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是CPU使用情况、内存使用情况、goroutine运行情况等</li></ul></li></ul><div class="tabs" id="tab-sixth"><ul class="nav-tabs"><li class="tab active"><a class="#sixth-1">字符串截取</a></li><li class="tab"><a class="#sixth-2">切片截取</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sixth-1"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 以下代码，会有10字节的内存泄漏，我们知道，str0和str1底层共享内存</span></span><br><span class="line">    <span class="comment">// 只要str1一直活跃，str0 就不会被回收，10字节的内存被使用</span></span><br><span class="line">    <span class="comment">// 剩下的10字节内存就造成了临时性的内存泄漏，直到str1不再活跃</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果str0足够大，str1截取足够小，或者在高并发场景中频繁使用</span></span><br><span class="line">    <span class="comment">// 那么可想而知，会造成临时性内存泄漏，对性能产生极大影响</span></span><br><span class="line">    <span class="keyword">var</span> str0 = <span class="string">&quot;12345678901234567890&quot;</span></span><br><span class="line">    str1 := str0[:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方案 1</span></span><br><span class="line">    <span class="comment">// 将需要截取的部分先转换成[]byte，再转换成string</span></span><br><span class="line">    <span class="comment">// 但是这种方式会产生两个10字节的临时变量</span></span><br><span class="line">    <span class="comment">// string转换[]byte时产生一个10字节临时变量，[]byte转换string时产生一个10字节的临时变量</span></span><br><span class="line">    str1 := <span class="type">string</span>([]<span class="type">byte</span>(str0[:<span class="number">10</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方案 2</span></span><br><span class="line">    <span class="comment">// 仍然有一个字节的浪费</span></span><br><span class="line">    str1 := (<span class="string">&quot; &quot;</span> + str0[:<span class="number">10</span>])[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方案 3</span></span><br><span class="line">    str1 := strings.Repeat(str0[:<span class="number">10</span>], <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="sixth-2"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这种情况与字符串截取引起的内存泄漏情况类似，s1活跃情况下，造成s0中部分内存泄漏</span></span><br><span class="line">	<span class="keyword">var</span> s0 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	s1 := s0[:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方案 append</span></span><br><span class="line">    s1 := <span class="built_in">append</span>(s0[:<span class="number">0</span>], s0[:<span class="number">5</span>]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div></div>
              </div>
            </details>

<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>是什么</strong><ul><li>通过指针的动态范围来决定一个变量分配在栈上还是堆上</li></ul></li><li><strong>为什么</strong><ul><li>总的来说就是让变量分配到合理的位置</li><li>栈区可以自动清理内存，效率高，但空间有限</li><li>堆区空间大，但不像栈可以自动清理，需要进行垃圾回收，导致运行效率低下</li><li>逃逸分析，把一次性的变量分配到栈区，把后续可能在外部引用的对象分配到堆区</li></ul></li><li><strong>内存逃逸</strong><ul><li>如果变量在函数外部没有被引用，则一般不发生内存逃逸，优先分配到栈区，如果栈区存不下会分配到堆区</li><li>如果变量在函数外部被引用（闭包也算作此种情况），则发生内存逃逸，一定分配到堆区</li><li>此外，如果不确定是否被外部引用，如fmt.Println(x)，由于函数参数为接口类型，不确定x是否为引用类型，也视为x发生逃逸</li></ul></li><li><strong>如何避免</strong><ul><li>尽量减少不必要的指针使用</li></ul></li></ul>
              </div>
            </details>

<h2 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>标记清除法（Go 1.3） </li><li>三色标记法（Go 1.5）</li><li>三色标记法+混合写屏障（Go 1.8）</li></ul><div class="tabs" id="tab-sixth"><ul class="nav-tabs"><li class="tab active"><a class="#sixth-1">标记清除法</a></li><li class="tab"><a class="#sixth-2">三色标记法</a></li><li class="tab"><a class="#sixth-3">三色标记法+混合写屏障</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sixth-1"><ul><li><p>过程</p><ul><li><p>进行 STW（stop the world 即暂停程序业务逻辑），然后从 main 函数开始找到不可达的对象和可达的对象</p></li><li><p>开始标记，程序找出可达对象并做标记</p></li><li><p>标记结束清除未标记的对象</p></li><li><p>结束 STW 停止暂停，让程序继续运行，循环该过程直到 main 生命周期结束</p></li></ul></li><li><p>缺点</p><ul><li><p>STW会让程序暂停，程序会出现卡顿</p></li><li><p>进行标记需要扫描整个堆栈信息，效率低下</p></li></ul></li></ul></div><div class="tab-pane" id="sixth-2"><ul><li><p><strong>含义</strong></p><ul><li>三色标记算法将程序中的对象分成白色、黑色和灰色三类</li><li>白色对象表示暂无对象引用的潜在垃圾，灰色表示待处理的对象，黑色表示活跃的对象</li></ul></li><li><p><strong>过程</strong></p><ul><li><p>将所有对象标记为白色</p></li><li><p>从程序根节点集合出发，将第一次遍历到的节点标记为灰色放入集合列表中</p></li><li><p>遍历灰色集合，将灰色节点遍历到的白色节点标记为灰色，并把灰色节点标记为黑色</p></li><li><p>循环这个过程，直到灰色节点集合为空</p></li><li><p>回收所有的白色节点</p></li></ul></li><li><p><strong>缺陷</strong></p><ul><li><p>因为三色标记法是动态进行的，回收过程中若<strong>同时满足下面两个条件</strong>，则会出现<strong>丢失对象</strong>的问题</p><ul><li><p>一个白色对象被黑色对象引用</p></li><li><p>同时灰色对象到该白色对象的可达关系被破环</p></li></ul></li></ul></li><li><p><strong>应对办法</strong></p><ul><li><p>插入写屏障：</p><ul><li><p>对象被引用时触发的机制，当白色对象被黑色对象引用时，白色对象被标记为灰色</p></li><li><p>实现了强三色不变式，即不允许黑色对象引用白色对象（破坏第一个条件）</p></li><li><p>缺点是栈区没有屏障机制，最后会对栈执行STW，进行二次扫描</p></li></ul></li><li><p>删除写屏障：</p><ul><li><p>对象被删除时触发的机制，灰色对象对白色对象的引用被删除时，白色对象会被标记为灰色</p></li><li><p>实现了弱三色不变式，即黑色对象可以引用白色，但是该白色对象要处在灰色对象可达的链路当中（破坏第二个条件）</p></li><li><p>缺点是回收精度比较低，有些垃圾对象会到下一轮检测才被回收；同时也会进行STW二次扫描进行快照对比</p></li></ul></li></ul></li></ul></div><div class="tab-pane" id="sixth-3"><ul><li><p><strong>思想</strong></p><ul><li>结合了插入写屏障和删除写屏障的优点，通过变形的弱三色不变式，解决了STW所带来的性能瓶颈</li></ul></li><li><p><strong>过程</strong></p><ul><li><p>GC 开始时将栈上可达对象全部标记为黑色（不需要二次扫描，无需 STW）</p></li><li><p>GC 期间，任何栈上创建的新对象均为黑色</p></li><li><p>被删除引用的对象标记为灰色</p></li><li><p>被添加引用的对象标记为灰色</p></li></ul></li></ul></div></div></div>
              </div>
            </details>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL面试题</title>
    <url>/Interview/mysql-interview/</url>
    <content><![CDATA[<h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-first"><ul class="nav-tabs"><li class="tab active"><a class="#first-1">数值类型</a></li><li class="tab"><a class="#first-2">日期时间类型</a></li><li class="tab"><a class="#first-3">字符串类型</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-1"><ul><li><strong>整数类型</strong>：<ul><li><code>TINYINT</code>：1 字节</li><li><code>SMALLINT</code>：2 字节</li><li><code>MEDIUMINT</code>：3 字节</li><li><code>INT</code> 或 <code>INTEGER</code>：4 字节</li><li><code>BIGINT</code>：8 字节</li></ul></li><li><strong>浮点数类型</strong>：<ul><li><code>FLOAT</code>：4 字节</li><li><code>DOUBLE</code>：8 字节</li></ul></li><li><strong>定点数类型</strong>：<ul><li><code>DECIMAL(M, D)</code>：精确小数，M 为总位数，D 为小数位数。</li></ul></li></ul></div><div class="tab-pane" id="first-2"><ul><li><code>DATE</code>：日期，格式为 <code>YYYY-MM-DD</code>。</li><li><code>TIME</code>：时间，格式为 <code>HH:MM:SS</code>。</li><li><code>DATETIME</code>：日期和时间，格式为 <code>YYYY-MM-DD HH:MM:SS</code>。</li><li><code>TIMESTAMP</code>：时间戳，范围从 <code>1970-01-01 00:00:01</code> UTC 到 <code>2038-01-19 03:14:07</code> UTC。</li><li><code>YEAR</code>：年份，格式为 <code>YYYY</code>。</li></ul></div><div class="tab-pane" id="first-3"><ul><li><p><strong>常用：</strong></p><ul><li><p><code>CHAR(M)</code>：固定长度字符串，M 为字符数，最多 255 个字符。</p></li><li><p><code>VARCHAR(M)</code>：可变长度字符串，M 为最大字符数，最多 65535 个字符。</p></li></ul></li><li><p><strong>文本类型</strong>：</p><ul><li><code>TINYTEXT</code>：最大长度 255 个字符。</li><li><code>TEXT</code>：最大长度 65535 个字符。</li><li><code>MEDIUMTEXT</code>：最大长度 16777215 个字符。</li><li><code>LONGTEXT</code>：最大长度 4294967295 个字符。</li></ul></li><li><p><strong>二进制大对象（BLOB）</strong>：</p><ul><li><code>TINYBLOB</code>：最大长度 255 字节。</li><li><code>BLOB</code>：最大长度 65535 字节。</li><li><code>MEDIUMBLOB</code>：最大长度 16777215 字节。</li><li><code>LONGBLOB</code>：最大长度 4294967295 字节。</li></ul></li></ul></div></div></div>
              </div>
            </details>

<h2 id="CHAR和VARCHAR的区别"><a href="#CHAR和VARCHAR的区别" class="headerlink" title="CHAR和VARCHAR的区别"></a>CHAR和VARCHAR的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>主要区别</strong><ul><li>CHAR 是定长的</li><li>VARCHAR 是变长的</li><li>效率上CHAR更高</li></ul></li><li><strong>存储和检索方式</strong><ul><li>CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格</li><li>VARCHAR 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理</li></ul></li><li><strong>使用场景</strong><ul><li>CHAR 更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码</li><li>VARCHAR 适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</li></ul></li></ul>
              </div>
            </details>

<h2 id="DATETIME-和-TIMESTAMP-的区别是什么"><a href="#DATETIME-和-TIMESTAMP-的区别是什么" class="headerlink" title="DATETIME 和 TIMESTAMP 的区别是什么"></a>DATETIME 和 TIMESTAMP 的区别是什么</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>格式区别</strong><ul><li>TIMESTAMP 和时区有关</li><li>DATETIME 类型没有时区信息</li></ul></li><li><strong>存储大小</strong><ul><li>TIMESTAMP 使用 4 个字节的存储空间</li><li>DATETIME 使用 8 个字节的存储空间</li></ul></li><li><strong>表示范围</strong><ul><li>TIMESTAMP：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li><li>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li></ul></li></ul>
              </div>
            </details>

<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>第一范式（1NF）</strong><ul><li>字段（或属性）是不可分割的最小单元，即不会有重复的列，体现原子性</li></ul></li><li><strong>第二范式（2NF）</strong><ul><li>满足 1NF 前提下，存在一个候选码，非主属性全部依赖该候选码，即存在主键，体现唯一性，专业术语则是消除部分函数依赖</li></ul></li><li><strong>第三范式（3NF）</strong><ul><li>满足 2NF 前提下，非主属性必须互不依赖，消除传递依赖</li></ul></li></ul>
              </div>
            </details>

<h2 id="INT-n-中的n如何理解"><a href="#INT-n-中的n如何理解" class="headerlink" title="INT(n)中的n如何理解"></a>INT(n)中的n如何理解</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong><code>n</code> 是显示宽度</strong>，不是存储位数或范围</li><li>如果没有使用 <code>ZEROFILL</code>，<code>n</code> 的作用可以忽略</li><li><code>INT(n)</code> 的存储空间和范围与 <code>n</code> 无关</li></ul>
              </div>
            </details>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>原子性（Atomicity）</strong><ul><li>事务中的所有操作要么全部完成，要么全部不完成，不会结束在中间某个点。这意味着事务是一个不可分割的工作单元。</li></ul></li><li><strong>一致性（Consistency）</strong><ul><li>事务必须保证数据库从一个一致的状态转移到另一个一致的状态。事务执行的结果必须符合所有预定义的规则和约束。</li></ul></li><li><strong>隔离性（Isolation）</strong><ul><li>并发执行的事务之间不会互相影响。每个事务都像是在系统上独立运行，即使有多个事务同时进行，它们也应该是隔离的，以防止数据损坏。</li></ul></li><li><strong>持久性（Durability）</strong><ul><li>一旦事务提交，它对数据库的改变就是永久性的，即使系统发生故障，这些改变也不会丢失。</li></ul></li></ul>
              </div>
            </details>

<h2 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>脏读（Dirty Read）</strong><ul><li>一个事务读取了另一个事务未提交的数据。如果那个事务最终回滚了，那么读取的数据就是无效的。</li></ul></li><li><strong>不可重复读（Non-repeatable Read）</strong><ul><li>在一个事务中，多次读取同一数据集合时，由于其他事务的介入，可能会得到不同的结果。这种情况通常发生在读已提交或更低的隔离级别。</li></ul></li><li><strong>幻读（Phantom Read）</strong><ul><li>在同一事务中，当同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。</li></ul></li></ul>
              </div>
            </details>

<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>读未提交（Read Uncommitted）</strong><ul><li>事务可以读取到其他未提交事务的更改</li><li>可能导致脏读，即读取到其他事务未提交的数据</li></ul></li><li><strong>读已提交（Read Committed）</strong><ul><li>事务只能读取到其他事务已经提交的更改，避免了脏读</li><li>但可能遇到不可重复读的问题，即在同一事务中，由于其他事务的更新，两次读取到的数据不一致。</li></ul></li><li><strong>可重复读（Repeatable Read）</strong><ul><li>事务在整个过程中可以看到一致的快照数据，解决了不可重复读的问题</li><li>但是不能防止幻读，即在同一事务中，同一个查询在不同的时间产生不同的结果集</li></ul></li><li><strong>串行化（Serializable）</strong><ul><li>最高的隔离级别，通过完全串行化执行事务来避免脏读、不可重复读和幻读</li><li>在这个级别，事务将被序列化，依次单独执行，从而提供了最严格的隔离</li><li>但是这也可能导致较慢的性能</li></ul></li></ul><blockquote><p><em><strong>Tip</strong></em></p><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免了幻读现象</p><ul><li>针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题</li><li>针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题</li></ul><p>但是如果同时存在快照读和当前读，那么依然会存在幻读的问题</p></blockquote>
              </div>
            </details>

<h2 id="四种隔离级别是如何实现的"><a href="#四种隔离级别是如何实现的" class="headerlink" title="四种隔离级别是如何实现的"></a>四种隔离级别是如何实现的</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>读未提交</strong><ul><li>直接读取最新的数据</li></ul></li><li><strong>串行化</strong><ul><li>通过加读写锁的方式来避免并行访问</li></ul></li><li><strong>读已提交&amp;可重复读</strong><ul><li>它们是通过 Read View 来实现的，它们的区别在于<strong>创建 Read View 的时机不同</strong></li><li>读已提交是在<strong>每次读取数据时</strong>重新生成一个 Read View</li><li>可重复读是在<strong>启动事务时</strong>生成一个 Read View，然后整个事务期间都在用这个 Read View</li></ul></li></ul>
              </div>
            </details>

<h2 id="Read-View的实现原理"><a href="#Read-View的实现原理" class="headerlink" title="Read View的实现原理"></a>Read View的实现原理<a id="readview"></a></h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-second"><ul class="nav-tabs"><li class="tab active"><a class="#second-1">数据结构</a></li><li class="tab"><a class="#second-2">工作原理</a></li></ul><div class="tab-content"><div class="tab-pane active" id="second-1"><ul><li>Read View本质上是一个<strong>保存事务ID的列表</strong></li><li><strong>四个重要字段</strong><ul><li>m_ids：创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，「活跃事务」指的是启动了但还没提交的事务</li><li>min_trx_id：在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值</li><li>max_trx_id：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1</li><li>creator_trx_id ：指的是创建该 Read View 的事务的事务 id</li></ul></li><li><strong>两个隐藏字段</strong><ul><li>trx_id：当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里</li><li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo log中，这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录</li></ul></li></ul></div><div class="tab-pane" id="second-2"><ul><li><p>一个事务去访问记录时，自己的更新记录总是可见的</p></li><li><p>如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见</p></li><li><p>如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见</p></li><li><p>如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中</p><ul><li><p>如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。</p></li><li><p>如果记录的 trx_id 不在 m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见</p></li></ul></li></ul><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/read-view.png"
                      alt="read-view"
                ></p></div></div></div>
              </div>
            </details>

<h2 id="事务是如何实现的"><a href="#事务是如何实现的" class="headerlink" title="事务是如何实现的"></a>事务是如何实现的</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>实现事务就是要实现事务的<strong>四大特性ACID</strong><ul><li><a href="#undo">原子性通过undo log保证</a></li><li><a href="#redo">持久性通过redo log保证</a></li><li>隔离性通过锁和MVCC保证</li><li>一致性由原子性、持久性、隔离性共同保证</li></ul></li></ul>
              </div>
            </details>

<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="如何选择存储引擎"><a href="#如何选择存储引擎" class="headerlink" title="如何选择存储引擎"></a>如何选择存储引擎</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>InnoDB</strong><ul><li>需要事务（如支付系统）</li><li>高并发写入（如电商订单）</li><li>要求数据完整性和崩溃恢复</li></ul></li><li><strong>MyISAM</strong><ul><li>读多写少（如新闻网站的文章表）</li></ul></li><li><strong>MEMORY</strong><ul><li>临时数据或缓存（如会话存储）</li></ul></li></ul>
              </div>
            </details>

<h2 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a>InnoDB和MyISAM的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/mysql-innodb-vs-myisam.png"
                      alt="innodb-vs-myisam"
                ></p>
              </div>
            </details>

<h2 id="如何优化InnoDB的性能"><a href="#如何优化InnoDB的性能" class="headerlink" title="如何优化InnoDB的性能"></a>如何优化InnoDB的性能</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>调整缓冲池大小<ul><li>增加缓存以减少磁盘I&#x2F;O</li></ul></li><li>调整日志文件大小<ul><li>由于Redo Log采用WAL（Write-Ahead Logging）机制，先写日志再更新数据，日志文件大小决定了更新数据的频率</li></ul></li></ul>
              </div>
            </details>

<h2 id="为什么InnoDB在并发写入时性能更好"><a href="#为什么InnoDB在并发写入时性能更好" class="headerlink" title="为什么InnoDB在并发写入时性能更好"></a>为什么InnoDB在并发写入时性能更好</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>行级锁</strong><ul><li>仅锁定涉及的行，其他行仍可操作，减少锁冲突</li></ul></li><li><strong>MVCC（多版本并发控制）</strong><ul><li>通过版本链实现非阻塞读，读写操作互不阻塞</li></ul></li></ul>
              </div>
            </details>

<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p>数据结构上分为</p><ul><li>B+树索引</li><li>哈希索引</li></ul></li><li><p>物理结构上分为</p><ul><li>聚集索引</li><li>二级索引</li></ul></li><li><p>应用上分为：</p><ul><li><p>主键索引</p></li><li><p>普通索引</p></li><li><p>唯一索引</p></li><li><p>联合索引</p></li><li><p>全文索引</p></li></ul></li></ul>
              </div>
            </details>

<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p>优点</p><ul><li><p>加快数据的检索速度</p></li><li><p>加快表和表之间的连接速度</p></li><li><p>可以显著减少查询中分组和排序的时间</p></li></ul></li><li><p>缺点</p><ul><li><p>创建和维护索引需要耗费时间，这种时间随着数据量的增加而增加，这样就降低了数据的维护速度</p></li><li><p>索引需要占物理空间，本质上是空间换时间</p></li></ul></li></ul>
              </div>
            </details>

<h2 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p>什么时候需要创建索引</p><ul><li><p>对于很大的表且存在频繁用于查询条件的列，考虑建立索引提高查询速度</p></li><li><p>具有唯一性的数据可以创建索引，可以更快速的通过该索引来确定某条记录</p></li><li><p>频繁使用排序、分组和联合操作的列，执行这些操作时，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作</p></li></ul></li><li><p>什么时候不需要创建索引</p><ul><li><p>小表不建议索引，由于数据较小，直接查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果</p></li><li><p>经常进行更新的字段不需要创建索引，这样会破环B+树的结构，重新调整的开销大</p></li><li><p>字段中存在大量重复数据，不需要创建索引，比如性别字段</p></li></ul></li></ul>
              </div>
            </details>

<h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p><strong>数据存储位置</strong>：</p><ul><li><p><strong>B树</strong>：所有节点都存储数据，包括内部节点和叶子节点。</p></li><li><p><strong>B+树</strong>：仅叶子节点存储数据，内部节点只存储键值，用于索引。</p></li></ul></li><li><p><strong>叶子节点结构</strong>：</p><ul><li><p><strong>B树</strong>：叶子节点独立，不相互连接。</p></li><li><p><strong>B+树</strong>：叶子节点通过指针相连，形成有序链表，便于范围查询。</p></li></ul></li><li><p><strong>查询效率</strong>：</p><ul><li><p><strong>B树</strong>：由于数据分布在所有节点，查询时间不稳定，可能很快找到数据，也可能需要遍历多层。</p></li><li><p><strong>B+树</strong>：查询路径长度固定，必须到达叶子节点，因此查询时间更稳定。</p></li></ul></li><li><p><strong>空间利用率</strong>：</p><ul><li><strong>B树</strong>：每个节点都存储数据，空间利用率相对较低。</li><li><strong>B+树</strong>：内部节点仅存储键值，能容纳更多索引，空间利用率更高。</li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li><strong>B树</strong>：适合随机读写较多的场景。</li><li><strong>B+树</strong>：适合范围查询和顺序访问较多的场景，如数据库索引和文件系统。</li></ul></li></ul>
              </div>
            </details>

<h2 id="B-树为什么比B树更适合用与数据库索引"><a href="#B-树为什么比B树更适合用与数据库索引" class="headerlink" title="B+树为什么比B树更适合用与数据库索引"></a>B+树为什么比B树更适合用与数据库索引</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>B+ 树减少了 IO 次数</strong><ul><li>由于索引文件很大因此索引文件存储在磁盘上，B+ 树的非叶子结点只存关键字不存数据，因而单个页可以存储更多的关键字，即一次性读入内存的需要查找的关键字也就越多，磁盘的随机 I&#x2F;O 读取次数相对就减少了。</li></ul></li><li><strong>B+ 树查询效率更稳定</strong><ul><li>由于B+树数据只存在在叶子结点上，所以查找效率固定为 O(log n)，而B树的数据分布在所有节点，查询时间存在抖动，所以 B+ 树的查询效率相比B树更加稳定。</li></ul></li><li><strong>B+ 树更加适合范围查找</strong><ul><li>B+ 树叶子结点之间用链表有序连接，所以扫描全部数据只需扫描一遍叶子结点，利于扫库和范围查询；B 树由于非叶子结点也存数据，所以只能通过中序遍历按序来扫。也就是说，对于范围查询和有序遍历而言，B+ 树的效率更高。</li></ul></li></ul>
              </div>
            </details>

<h2 id="B-树相对于二叉树和Hash的优势"><a href="#B-树相对于二叉树和Hash的优势" class="headerlink" title="B+树相对于二叉树和Hash的优势"></a>B+树相对于二叉树和Hash的优势</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>相对于二叉树，B+树的层数更少，查询效率更高</li><li>相对于Hash，B+树支持范围匹配和排序操作</li></ul>
              </div>
            </details>

<h2 id="B-树查询数据的过程"><a href="#B-树查询数据的过程" class="headerlink" title="B+树查询数据的过程"></a>B+树查询数据的过程</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>定位根节点<ul><li>从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页</li></ul></li><li>内部节点遍历<ul><li>在内部节点中，继续定位到合适的子节点，并移动到该子节点，循环此过程直至到达叶子节点</li></ul></li><li>叶子节点遍历<ul><li>在叶子节点中，由于数据已排序，可以直接使用二分查找或顺序查找定位到具体的数据记录</li></ul></li></ul>
              </div>
            </details>

<h2 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>最左匹配原则主要用来处理使用联合索引时可能出现的一些问题</li><li>最左匹配原则要求查询条件中的列应该从索引的最左边的列开始，并且不能跳过中间的列</li><li>如果查询条件不按照索引的顺序进行匹配，那么索引可能会失效或者部分失效</li></ul>
              </div>
            </details>

<h2 id="回表查询和覆盖索引"><a href="#回表查询和覆盖索引" class="headerlink" title="回表查询和覆盖索引"></a>回表查询和覆盖索引</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>回表查询</strong><ul><li>因为二级索引只有索引和id字段的信息，如果要获取到其他字段，就需要通过id字段到聚簇索引中再次查询，这个过程就叫回表查询</li></ul></li><li><strong>覆盖索引</strong><ul><li>将select中的列包含在索引之中，这样在查找时就可以直接返回对应的字段信息，避免了回表查询</li></ul></li></ul>
              </div>
            </details>

<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>原理</strong><ul><li>对于较长的文本字段，直接对整个字段创建索引会占用大量存储空间，并且索引维护的开销较大。</li><li>前缀索引只对字段的前 <code>N</code> 个字符创建索引，从而减少索引大小，节省空间并提高查询效率。</li><li>例如，对 <code>desc VARCHAR(255)</code> 的字段，可以只对前 10 个字符创建索引<code>CREATE INDEX index_name ON table_name (desc(10))</code>。</li></ul></li><li><strong>注意事项</strong><ul><li><strong>区分度不足</strong>：如果前缀长度过短，可能导致大量重复值，降低查询效率。</li><li><strong>查询条件匹配</strong>：查询条件必须使用前缀匹配（如 <code>LIKE &#39;abc%&#39;</code>），否则无法利用前缀索引。</li><li><strong>排序和分组</strong>：前缀索引不支持 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。</li><li><strong>覆盖索引</strong>：前缀索引无法覆盖查询，因为只索引了部分字段。</li></ul></li></ul>
              </div>
            </details>

<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>在使用非主键索引进行查询时，如果索引列中存在某些判断条件时，会优先通过这些判断条件过滤掉不满足条件的数据，之后再进行回表操作进一步确定满足条件的数据</li><li>可以有效减少回表查询的次数，大大提升查询的效率</li></ul>
              </div>
            </details>

<h2 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>查询条件中有or且条件字段多于一个时，即使有部分条件带索引也会失效</li><li>like查询是以%开头</li><li>字段类型不匹配时索引会失效</li><li>索引列参与计算会导致索引失效</li><li>违背最左匹配原则</li></ul>
              </div>
            </details>

<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>选择合适的索引类型和列</strong><ul><li>单列索引</li><li>复合索引</li><li>全文索引</li></ul></li><li><strong>避免索引失效和冗余</strong><ul><li>见索引失效的情况</li><li>删除重复或冗余的索引，如果已有索引 <code>(a, b)</code>，则索引 <code>(a)</code> 可能是冗余的</li></ul></li><li><strong>合理利用覆盖索引和前缀索引</strong><ul><li>见覆盖索引和前缀索引</li></ul></li></ul>
              </div>
            </details>

<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="MySQL锁的类型"><a href="#MySQL锁的类型" class="headerlink" title="MySQL锁的类型"></a>MySQL锁的类型</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-third"><ul class="nav-tabs"><li class="tab active"><a class="#third-1">全局锁</a></li><li class="tab"><a class="#third-2">表级锁</a></li><li class="tab"><a class="#third-3">行级锁</a></li></ul><div class="tab-content"><div class="tab-pane active" id="third-1"><ul><li><p><strong>作用</strong></p><ul><li>使<strong>整个数据库</strong>处于<strong>只读状态</strong></li></ul></li><li><p><strong>使用方法</strong></p><ul><li>开启全局锁：<code>flush tables with read lock</code></li><li>释放全局锁：<code>unlock tables</code></li></ul></li><li><p><strong>优缺点</strong></p><ul><li>开启全局锁后所有对数据的修改操作都不允许，保证了数据的一致性，适合做全库逻辑备份</li><li>全局锁开启期间，所有写操作都会被阻塞，容易导致业务停滞</li></ul></li></ul><blockquote><p><em><strong>Tip</strong></em></p><p>如果数据库的存储引擎支持事务的可重复读隔离级别，那么就可以避免全局锁导致的写操作阻塞，因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View</p></blockquote></div><div class="tab-pane" id="third-2"><ul><li><p><strong>表锁</strong></p><ul><li>锁定整张表</li><li>通过 <code>LOCK TABLES table_name READ/WRITE</code> 添加表级共享锁（读锁）&#x2F;独占锁（写锁）</li><li>读锁允许其他事务读取表，但阻止写操作；写锁阻止其他事务的读、写操作。</li></ul></li><li><p><strong>元数据锁</strong></p><ul><li><strong>保护表结构，防止在表结构变更时进行读写操作，反之亦然</strong></li><li>对数据库表进行操作时，会自动给这个表加上 MDL，在<strong>事务提交后才会释放</strong><ul><li>对一张表进行 CRUD 操作时，加的是 MDL 读锁</li><li>对一张表做结构变更操作的时候，加的是 MDL 写锁</li></ul></li></ul></li><li><p><strong>意向锁</strong></p><ul><li><strong>用来快速判断表里是否有记录被加锁</strong></li><li>也分为<strong>意向共享锁</strong>和<strong>意向独占锁</strong></li><li>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁<code>lock tables ... read</code>或独占表锁发<code>lock tables ... write</code>生冲突</li><li>因为在使用 InnoDB 引擎的表里对某些记录加上「共享锁&#x2F;独占锁」之前，需要先在表级别加上一个「意向共享锁&#x2F;意向独占锁」，那么再给表加「独占表锁」时，会先检查该表是否存在「意向共享锁&#x2F;意向独占锁」，如果有就意味着表里已经有记录被加了「共享锁&#x2F;独占锁」，这样就避免了加「独占表锁」时去遍历全部数据来判断表里是否有记录被加了锁</li></ul></li><li><p><strong>自增锁</strong></p><ul><li>保证被<code>AUTO_INCRMENT</code>修饰的字段是连续递增的</li><li>在插入数据时会加一个自增锁，插入操作执行完毕后立即释放，而不必等待整个事务提交才释放</li></ul></li></ul></div><div class="tab-pane" id="third-3"><ul><li><strong>记录锁</strong><ul><li>锁住的是一条记录</li></ul></li><li><strong>间隙锁</strong><ul><li>锁住的是两条记录之间的间隙，存在于RR隔离级别，防止其他事务在这个间隙进行INSERT操作，目的是为了解决幻读的现象</li></ul></li><li><strong>临键锁</strong><ul><li>锁住的是一个范围，并且包括记录本身（左闭右开区间），相当于记录锁+临键锁，存在于RR隔离级别，也是为了解决幻读的现象</li></ul></li><li><strong>插入意向锁</strong><ul><li><p>一种特殊的间隙锁，属于行级别锁</p><ul><li>假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁，当事务 A 还没提交的时候，事务 B 向该表插入一条 id &#x3D; 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态，此时事务 B 就会发生阻塞，直到事务 A 提交了事务</li><li>如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</li></ul></li><li><p>尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）</p></li></ul></li></ul></div></div></div>
              </div>
            </details>

<h2 id="MySQL是如何加行级锁的"><a href="#MySQL是如何加行级锁的" class="headerlink" title="MySQL是如何加行级锁的"></a>MySQL是如何加行级锁的</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>MySQL加锁的对象是索引，加锁的基本单位是「临键锁」</li><li>唯一索引加锁只加在唯一索引项上；非唯一索引加锁同时加在普通索引项和主键索引项上；不走索引会给所有记录加锁，相当于锁住全表</li><li>但是某些的场景下，「临键锁」会退化成「记录锁」或「间隙锁」</li></ul><div class="tabs" id="tab-fourth"><ul class="nav-tabs"><li class="tab active"><a class="#fourth-1">唯一索引</a></li><li class="tab"><a class="#fourth-2">非唯一索引</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fourth-1"><ul><li><strong>等值查询</strong><ul><li>当查询的记录是「存在」的，该记录索引的「临键锁」会退化成「记录锁」</li><li>当查询的记录是「不存在」的，先找到第一条大于该记录的记录，该记录索引的「临键锁」会退化成「间隙锁」</li></ul></li><li><strong>范围查询</strong><ul><li>针对「大于」或「大于等于」的范围查询<ul><li>如果边界记录不在表中<ul><li>不管是「大于」还是「大于等于」，会对每一个扫描到的索引项加「临键锁」</li></ul></li><li>如果边界记录存在于表中<ul><li>对于「大于」，依然对每一个扫描到的索引项加「临键锁」</li><li>对于「大于等于」，该边界记录索引的「临键锁」会退化成「记录锁」，其他扫描到的索引项加「临键锁」</li></ul></li></ul></li><li>针对「小于」或「小于等于」的范围查询<ul><li>如果边界记录不在表中<ul><li>不管是「小于」还是「小于等于」，先找到第一条大于该记录的记录，该记录索引的「临键锁」锁会退化成「间隙锁」，其他扫描到的索引项加「临键锁」</li></ul></li><li>如果边界记录存在于表中<ul><li>对于「小于」，边界记录索引的「临键锁」会退化成「间隙锁」，其他扫描到的索引项加「临键锁」</li><li>对于「小于等于」，直接对每一个扫描到的索引项加「临键锁」</li></ul></li></ul></li></ul></li></ul></div><div class="tab-pane" id="fourth-2"><ul><li><strong>等值查询</strong><ul><li>记录「存在」时，首先对该记录主键索引加「记录锁」，然后扫描寻找符合条件的记录，对这些记录的二级索引加「临键锁」，最后找到第一个不符合条件终止记录，对终止记录加「间隙锁」</li><li>记录「不存在」时，扫描找到第一个不符合条件终止记录，对该记录加「间隙锁」</li></ul></li><li><strong>范围查询</strong><ul><li>对所有扫描到的索引项，不管是主键索引还是二级索引，都加「临键锁」，不存在「临键锁」退化的情况</li></ul></li></ul></div></div></div>
              </div>
            </details>

<h2 id="MySQL死锁"><a href="#MySQL死锁" class="headerlink" title="MySQL死锁"></a>MySQL死锁</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p>死锁是指在两个或多个事务在执行过程中，因争夺资源而互相等待的现象。简单来说，就是事务A等待事务B释放资源，而事务B又在等待事务A释放资源，最终导致双方都无法完成。</p></li><li><p><strong>解决死锁的方法</strong></p><ul><li><p>设置事务等待锁的超时时间。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。</p></li><li><p>开启主动死锁检测。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。</p></li></ul></li></ul>
              </div>
            </details>

<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-fifth"><ul class="nav-tabs"><li class="tab active"><a class="#fifth-1">乐观锁</a></li><li class="tab"><a class="#fifth-2">悲观锁</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fifth-1"><ul><li><strong>原理</strong><ul><li>乐观锁假设数据冲突较少，所以在读取数据时不会加锁，而是在更新数据时通过版本号或时间戳来检测数据是否被其他事务修改，常见的实现方式是在数据表中增加一个版本号（version）字段，更新时同时检查版本号是否与之前读取的一致，如果受影响的行数为0，则说明数据在此期间被其他事务修改，更新操作就会失败，应用程序可以选择重新读取数据并重试。</li></ul></li><li><strong>特点</strong><ul><li><strong>高并发性能</strong>：读操作时无需加锁，降低了锁竞争，适合高并发场景。</li><li><strong>冲突检测</strong>：通过版本号等机制在更新时检测数据冲突，确保数据一致性。</li><li><strong>冲突处理</strong>：当冲突发生时需要应用程序层面处理，比如重试或报错，业务逻辑可能因此复杂化。</li></ul></li><li><strong>适用场景</strong><ul><li>系统读多写少的场景或者并发冲突较少的应用。</li><li>业务场景允许在冲突发生时进行重试或补救措施。</li></ul></li></ul></div><div class="tab-pane" id="fifth-2"><ul><li><p><strong>原理</strong></p><ul><li>悲观锁假设数据竞争会频繁发生，因此在每次操作数据时都会先对数据进行加锁。比如在使用InnoDB存储引擎时，可以通过 <code>SELECT ... FOR UPDATE</code> 对查询到的记录加排他锁，从而防止其他事务对这些记录进行修改。</li></ul></li><li><p><strong>特点</strong></p><ul><li><p><strong>严格控制并发</strong>：在加锁期间，其他事务无法修改甚至读取被锁定的数据（根据锁类型不同，可能允许读操作，但通常都是锁住写操作）。</p></li><li><p><strong>数据安全性高</strong>：适合在竞争激烈、数据一致性要求高的场景下使用。</p></li><li><p><strong>性能开销</strong>：由于需要频繁加锁和解锁，且锁会导致事务等待，可能降低并发性能。</p></li></ul></li><li><p><strong>适用场景</strong></p><ul><li><p>写操作频繁且冲突可能性较高的系统。</p></li><li><p>对数据一致性要求非常严格、容忍较低并发的业务场景。</p></li></ul></li></ul></div></div></div>
              </div>
            </details>

<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="MySQL中常见的日志"><a href="#MySQL中常见的日志" class="headerlink" title="MySQL中常见的日志"></a>MySQL中常见的日志</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p><strong>回滚日志（Undo Log）：</strong> 保存了事务发生之前的数据的一个版本，作用是通过回滚<strong>保证事务的原子性</strong>和<strong>配合Read View实现MVCC</strong>。</p></li><li><p><strong>重做日志（Redo Log）：<strong>记录了事务执行后的状态，用来恢复未写入 data file 的已提交事务数据，作用是用于掉电等故障的恢复，以</strong>确保事务的持久性</strong>。</p></li><li><p><strong>二进制日志（Bin Log）：<strong>Server 层生成的日志，主要</strong>用于数据备份和主从复制</strong>；</p></li><li><p>**普通查询日志（General Query Log）：**记录了服务器接收到的每一个命令，无论命令语句是否正确，因此会带来不小开销，所以也是默认关闭的。</p></li><li><p><strong>慢查询日志（Slow Query Log）：<strong>记录执行时间过长和没有使用索引的查询语句（默认 10s），同时</strong>只会记录执行成功的语句</strong>。</p></li></ul>
              </div>
            </details>

<h2 id="Undo-Log如何保证事务的原子性"><a href="#Undo-Log如何保证事务的原子性" class="headerlink" title="Undo Log如何保证事务的原子性"></a>Undo Log如何保证事务的原子性<a id="undo"></a></h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：<ul><li>插入一条记录时，要把这条记录的主键值记下来，回滚时只需要把这个主键值对应的记录删掉即可</li><li>删除一条记录时，要把这条记录中的内容都记下来，回滚时把由这些内容组成的记录插入到表中</li><li>更新一条记录时，要把被更新的列的旧值记下来，回滚时把这些列更新为旧值</li></ul></li></ul>
              </div>
            </details>

<h2 id="Redo-Log如何保证事务的持久性"><a href="#Redo-Log如何保证事务的持久性" class="headerlink" title="Redo Log如何保证事务的持久性"></a>Redo Log如何保证事务的持久性<a id="redo"></a></h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>InnoDB 使用了一种叫做 <strong>Write-Ahead Logging (WAL)</strong> 的技术，Redo Log 是 WAL 的具体实现。</li><li><strong>工作原理</strong><ul><li><strong>事务执行时</strong>：<ul><li>当事务修改数据时，InnoDB 首先将修改操作记录到内存中的 <strong>Buffer Pool</strong>（缓冲池），而不是直接写到磁盘上的数据文件。</li><li>同时，这些修改会被记录到 <strong>Redo Log Buffer</strong>（重做日志缓冲区）中。</li></ul></li><li><strong>事务提交时</strong>：<ul><li>Redo Log Buffer 中的日志会被写入磁盘上的 <strong>Redo Log 文件</strong>（通常是 ib_logfile0 和 ib_logfile1）。</li><li>只有当 Redo Log 成功写入磁盘后，事务才算真正提交成功。</li><li>数据文件的实际修改（脏页刷新）可以延迟进行，由后台线程异步完成。</li></ul></li><li><strong>崩溃恢复时</strong>：<ul><li>如果系统在事务提交后但数据文件未更新前崩溃，InnoDB 会利用磁盘上的 Redo Log 重放已提交事务的修改，恢复数据到一致状态。</li></ul></li></ul></li></ul>
              </div>
            </details>

<h2 id="Redo-Log什么时候刷盘"><a href="#Redo-Log什么时候刷盘" class="headerlink" title="Redo Log什么时候刷盘"></a>Redo Log什么时候刷盘</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>MySQL正常关闭时</li><li>Redo Log Buffer空间不足时</li><li>后台线程定期异步刷新</li><li>事务提交时（由 innodb_flush_log_at_trx_commit 参数控制，默认为1）<ul><li>参数为0时，不主动触发刷盘</li><li>参数为1时，每次事务提交时，Redo Log Buffer 中的日志立即写入磁盘，并调用 fsync 确保落盘</li><li>参数为2时，每次事务提交时，日志写入操作系统缓存，转由操作系统控制落盘时机</li></ul></li></ul>
              </div>
            </details>

<h2 id="Redo-Log和Bin-Log有什么不同"><a href="#Redo-Log和Bin-Log有什么不同" class="headerlink" title="Redo Log和Bin Log有什么不同"></a>Redo Log和Bin Log有什么不同</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>适用对象不同</strong><ul><li>Bin Log 是 MySQL的 Server 层实现的，所有存储引擎都可以使用</li><li>Redo Log 是lnnodb 存储引擎实现的日志</li></ul></li><li><strong>文件格式不同</strong><ul><li>Redo Log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</li><li>Bin Log有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED<ul><li>STATEMENT：每一条修改数据的 SQL 都会被记录到 Bin Log 中（相当于记录了逻辑操作，所以针对这种格式， Bin Log 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如用了 uuid 或者 now 这些函数，在主库上执行的结果和在从库执行的结果不一致，这种随时在变的函数会导致复制的数据不一致</li><li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已</li><li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式</li></ul></li></ul></li><li><strong>写入方式不同</strong><ul><li>Bin Log 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志</li><li>Redo Log是循环写，日志空间大小固定，全部写满就从头开始</li></ul></li><li><strong>用途不同</strong><ul><li>Bin Log 用于备份恢复、主从复制</li><li>Redo Log 用于故障后的数据恢复</li></ul></li></ul>
              </div>
            </details>

<h2 id="Bin-Log什么时候刷盘"><a href="#Bin-Log什么时候刷盘" class="headerlink" title="Bin Log什么时候刷盘"></a>Bin Log什么时候刷盘</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <p>MySQL提供一个 sync_binlog 参数来控制数据库的 Bin Log 刷到磁盘上的频率</p><ul><li>sync_binlog &#x3D; 0 的时候，每次提交事务都只写入到操作系统缓存，后续交由操作系统决定何时将数据持久化到磁盘</li><li>sync_binlog &#x3D; 1 的时候，每次提交事务都会马上执行刷盘</li><li>sync_binlog &#x3D;N（N&gt;1） 的时候，累积 N 个事务后一起刷盘</li></ul>
              </div>
            </details>

<h2 id="两段提交"><a href="#两段提交" class="headerlink" title="两段提交"></a>两段提交</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>事务提交后，Redo Log 和 Bin Log 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致，在主从架构中，两者无论是哪一个单独成功，最终都会导致主从不一致的问题，「两段提交」就是为应对该问题的解决方案，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</li><li><strong>两段提交过程</strong><ul><li>Prepare阶段<ul><li>将 XA 事务的写入到 Redo Log，同时将 Redo Log 对应的事务状态设置为 prepare，然后将 Redo Log持久化到磁盘</li></ul></li><li>Commit阶段<ul><li>把 XID 写入到 Bin Log，然后将 Bin Log 持久化到磁盘，接着调用引擎的提交事务接口，将 Redo Log 状态设置为 commit</li></ul></li></ul></li><li>两段提交的核心点就是将Redo Log的写入拆分成两个阶段，以此确保确保 Redo Log 和 Bin Log 之间的顺序和一致性</li><li><strong>两段提交的问题</strong><ul><li>磁盘IO次数高：每次事务提交都要进行两次刷盘，一次是 redo log 刷盘，另一次是 binlog 刷盘</li><li>锁竞争激烈：在多事务的场景下，需要通过加锁来确保两个事务提交顺序一致</li></ul></li></ul>
              </div>
            </details>

<h1 id="进阶部分"><a href="#进阶部分" class="headerlink" title="进阶部分"></a>进阶部分</h1><h2 id="MySQL逻辑框架"><a href="#MySQL逻辑框架" class="headerlink" title="MySQL逻辑框架"></a>MySQL逻辑框架</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/mysql-framework.png"
                      alt="mysql-framework"
                ></p>
              </div>
            </details>

<h2 id="一条SQL语句的总体流程"><a href="#一条SQL语句的总体流程" class="headerlink" title="一条SQL语句的总体流程"></a>一条SQL语句的总体流程</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ol><li>**连接器：**建立连接，管理连接、校验用户身份</li><li>**查询缓存：**查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块</li><li>**分析器：**通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型</li><li>**优化器：**决定使用哪个索引，或者在一个语句有多表关联（join）时，决定各个表的连接顺序，生成执行成本最小的执行计划</li><li>**执行器：**根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端</li></ol>
              </div>
            </details>

<h2 id="一条Update语句的具体执行流程"><a href="#一条Update语句的具体执行流程" class="headerlink" title="一条Update语句的具体执行流程"></a>一条Update语句的具体执行流程</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ol start="0"><li>连接器、分析器、优化器</li><li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取要更新的记录<ul><li>如果记录所在的数据页就在 buffer pool 中，直接返回给执行器更新</li><li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器</li></ul></li><li>执行器得到聚簇索引记录后，会检查更新前的记录和更新后的记录是否一样<ul><li>如果一样的话就不进行后续更新流程</li><li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作</li></ul></li><li>开启事务， InnoDB 层更新记录前，首先需要把被更新的列的旧值记下来，生成一条 Undo Log，Undo Log 会写入 Buffer Pool 中的 Undo 页面</li><li>InnoDB在Buffer Pool中更新对应的数据页，并将该数据页标记为脏页，然后通过WAL技术，先写Redo Log，之后在合适的时机将脏页持久化到磁盘</li><li>然后开始记录该语句对应的Bin Log，也在合适的时机刷盘，默认是在事务提交时刷盘</li><li>事务提交阶段，两段提交</li><li>至此完成一条更新语句</li></ol>
              </div>
            </details>

<h2 id="MVCC是什么"><a href="#MVCC是什么" class="headerlink" title="MVCC是什么"></a>MVCC是什么</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>MVCC（Multi-Version Concurrency Control，多版本并发控制）是MySQL InnoDB 存储引擎用来提高并发性能并减少事务锁竞争的一种机制，它允许数据库同时存在多个版本的数据，实现读写不冲突，从而提升性能</li><li>主要通过Undo Log和<a href="#readview">Read View</a>来实现</li></ul>
              </div>
            </details>

<h2 id="SQL调优"><a href="#SQL调优" class="headerlink" title="SQL调优"></a>SQL调优</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>计数时尽量使用COUNT(1)或COUNT(*)</li><li>查询时尽量使用SELECT(明确字段)<ul><li>优化器解析<code>*</code>符号为所有列名要耗费时间，并且<code>*</code>号无法使用覆盖索引</li></ul></li><li>使用limit N，少用limit M，N，避免深度分页</li><li>尽量UNION ALL而不是UNION<ul><li>UNION ALL不去重，速度更快</li></ul></li></ul>
              </div>
            </details>

<h2 id="查询速度慢如何分析"><a href="#查询速度慢如何分析" class="headerlink" title="查询速度慢如何分析"></a>查询速度慢如何分析</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p><strong>分析查询语句</strong></p><ul><li>使用EXPLAIN命令分析SQL执行计划，找出慢查询的原因，比如是否使用了全表扫描，是否存在索引未被利用的情况等，并根据相应情况对索引进行适当修改。</li></ul></li><li><p>SQL<strong>优化角度</strong></p><ul><li><a href="#SQL%E8%B0%83%E4%BC%98">SQL调优</a></li></ul></li><li><p><strong>索引优化角度</strong></p><ul><li><p>创建或优化索引：根据查询条件创建合适的索引，特别是经常用于WHERE子句的字段、Orderby 排序的字段、Join 连表查询的字典、 group by的字段，并且如果查询中经常涉及多个字段，考虑创建联合索引，使用联合索引要符合最左匹配原则，不然会索引失效</p></li><li><p>避免索引失效：比如不要用左模糊匹配、函数计算、表达式计算等等。</p></li></ul></li><li><p><strong>数据库优化角度</strong></p><ul><li><p>优化数据库表</p><ul><li>如果单表的数据超过了千万级别，考虑是否需要将大表拆分为小表，减轻单个表的查询压力。</li><li>也可以将字段多的表分解成多个表，有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开。</li></ul></li><li><p>使用缓存技术</p><ul><li>引入缓存层，如Redis，存储热点数据和频繁查询的结果，但是要考虑缓存一致性的问题，对于读请求会选择旁路缓存策略，对于写请求会选择先更新 db，再删除缓存的策略。</li></ul></li></ul></li></ul>
              </div>
            </details>

<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>主从复制主要实现数据的备份、读写分离功能，主库负责写，从库负责读</li><li><strong>主从复制的原理</strong><ul><li>首先主库将表的变更写入binlog日志</li><li>然后从库连接到主库，通过IO线程将主库binlog日志拷贝到本地，写入到中继日志中</li><li>从库有一个sql线程会从中继日志读取binlog日志，相当于在本地再执行一遍SQL</li></ul></li><li><strong>主从复制的同步方式</strong><ul><li>同步复制<ul><li>MySQL 主库提交事务的线程等待所有从库的复制成功响应，才返回客户端结果</li><li>一般不使用这种方式，因为性能和可用性都比较差</li></ul></li><li>异步复制（默认）<ul><li>MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。</li><li>这种模式一旦主库宕机，数据就会发生丢失。</li></ul></li><li>半同步复制<ul><li>MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行</li><li>这种半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</li></ul></li></ul></li></ul>
              </div>
            </details>

<h2 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-sixth"><ul class="nav-tabs"><li class="tab active"><a class="#sixth-1">分库</a></li><li class="tab"><a class="#sixth-2">分表</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sixth-1"><ul><li><p>为什么要分库</p><ul><li><p>磁盘容量有限</p></li><li><p>数据库的连接数有限，高并发场景下，会出现too many connections报错</p></li></ul></li><li><p>分库的好处</p><ul><li><p>解决了单库大数据，高并发的性能瓶颈</p></li><li><p>可以降低单机硬件资源的瓶颈</p></li></ul></li><li><p>分库的方式</p><ul><li><p>水平分库</p><ul><li>把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上</li></ul></li><li><p>垂直分库</p><ul><li>将表按业务分类，然后分布在不同数据库，部署在不同服务器上</li></ul></li></ul></li></ul></div><div class="tab-pane" id="sixth-2"><ul><li><p>为什么要分表</p><ul><li><p>单表数据量太大，做了很多优化仍然无法提升效率</p></li><li><p>索引一般是B+树存储结构，B+树高度增高，查询会过慢</p></li></ul></li><li><p>分表的好处</p><ul><li><p>优化单一表数据量过大而产生的性能问题</p></li><li><p>避免IO争抢并减少锁表的几率</p></li></ul></li><li><p>分表的方式</p><ul><li><p>水平分表</p><ul><li>在同一个数据库内，把同一个表的数据按一定规则拆到多个表中</li></ul></li><li><p>垂直分表</p><ul><li>将一个表按照字段分成多表，每个表存储其中一部分字段</li></ul></li></ul></li></ul></div></div></div>
              </div>
            </details>

<h2 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>事务一致性问题</strong><ul><li>由于分库分表把数据分布在不同库甚至不同服务器，不可避免会带来分布式事务问题。</li></ul></li><li><strong>跨节点关联查询</strong><ul><li>垂直分库后两张表的信息不在一个数据库，甚至不在一台服务器，也无法进行关联查询</li><li>可将原关联查询分为两次查询，第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据，最后将获得到的数据进行拼装</li></ul></li><li><strong>跨节点分页排序</strong><ul><li>跨节点多库进行查询时，limit分页、order by排序等问题，就变得比较复杂了，需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序</li></ul></li><li><strong>主键避重</strong><ul><li>在分库分表环境中，由于表中数据同时存在不同数据库中，主键值使用的自增长将无法使用，某个分区数据库生成的ID无法保证全局唯一，因此需要单独设计全局主键，以避免跨库主键重复问题</li></ul></li></ul>
              </div>
            </details>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/Hello-World/hello-world/</url>
    <content><![CDATA[<div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 面试题</title>
    <url>/Interview/Redis-interview/</url>
    <content><![CDATA[<h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><h2 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>基于内存</strong><ul><li>避免了磁盘IO，提高了操作的速度</li></ul></li><li><strong>单线程</strong><ul><li>单线程操作省去了上下文切换带来的开销和CPU的消耗，同时不存在资源竞争，避免了死锁现象的发生</li></ul></li><li><strong>IO多路复用</strong><ul><li>采用IO多路复用机制，允许一个线程同时监听多个Socket请求，根据Socket上的事件来选择对应的事件处理器进行处理</li></ul></li></ul>
              </div>
            </details>

<h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-redis-data-type-common"><ul class="nav-tabs"><li class="tab active"><a class="#redis-data-type-common-1">String</a></li><li class="tab"><a class="#redis-data-type-common-2">List</a></li><li class="tab"><a class="#redis-data-type-common-3">Hash</a></li><li class="tab"><a class="#redis-data-type-common-4">Set</a></li><li class="tab"><a class="#redis-data-type-common-5">ZSet</a></li></ul><div class="tab-content"><div class="tab-pane active" id="redis-data-type-common-1"><ul><li>String 是最基本的 key-value 结构，底层的数据结构由 <strong>int 和 SDS</strong>（简单动态字符串）实现<ul><li>如果value是整数，那么就使用int类型存放</li><li>否则使用SDS存放</li></ul></li><li><strong>应用场景</strong><ul><li>缓存对象的json</li><li>计数场景<ul><li>如访问次数、点赞、转发</li></ul></li></ul></li></ul></div><div class="tab-pane" id="redis-data-type-common-2"><ul><li>List是简单的字符串列表，按照插入顺序排序，可以从头部或尾部向 List 列表添加元素，底层数据结构由<strong>quickList</strong>实现</li><li><strong>应用场景</strong><ul><li>消息队列</li></ul></li></ul></div><div class="tab-pane" id="redis-data-type-common-3"><ul><li>Hash是一个key-value键值对的集合，底层数据结构由<strong>listpack或哈希表</strong>实现<ul><li>默认情况下，如果哈希类型元素个数小于512个，所有值小于64B，Redis会使用listpack作为Hash类型的底层实现</li><li>否则使用哈希表作为Hash类型的底层实现</li></ul></li><li><strong>应用场景</strong><ul><li>缓存对象<ul><li>相比于使用String缓存对象的json，Hash更适合缓存数据量比较大的对象或某些字段需要频繁修改的对象</li></ul></li></ul></li></ul></div><div class="tab-pane" id="redis-data-type-common-4"><ul><li>Set是一个无序且唯一的字符串集合，底层数据结构由<strong>整数集合或哈希表</strong>实现<ul><li>默认情况下，如果集合中所有元素都是整数且元素个素小于512个，Redis会使用整数集合作为Set类型的底层实现</li><li>否则使用哈希表作为Set类型的底层实现</li></ul></li><li><strong>应用场景</strong><ul><li>点赞<ul><li>保证一个用户只能点一个赞</li></ul></li><li>共同关注<ul><li>使用交集运算，可以用来计算好友共同关注的对象</li><li>使用差集运算，A给B推荐B没有关注的对象</li></ul></li></ul></li></ul></div><div class="tab-pane" id="redis-data-type-common-5"><ul><li>ZSet相比Set多了一个分数属性，保留了Set元素唯一的特性，不同的是ZSet中的元素可以通过分数排序，底层数据结构由<strong>listpack或跳表</strong>实现<ul><li>如果ZSet中元素个数小于128个，并且每个元素的值小于64B时，Redis会使用listpack作为ZSet类型的底层实现</li><li>否则使用跳表作为Set类型的底层实现</li></ul></li><li><strong>应用场景</strong><ul><li>排行榜</li></ul></li></ul></div></div></div><div class="tabs" id="tab-redis-data-type-other"><ul class="nav-tabs"><li class="tab active"><a class="#redis-data-type-other-1">BitMap</a></li><li class="tab"><a class="#redis-data-type-other-2">HyperLogLog</a></li><li class="tab"><a class="#redis-data-type-other-3">GEO</a></li><li class="tab"><a class="#redis-data-type-other-4">Stream</a></li></ul><div class="tab-content"><div class="tab-pane active" id="redis-data-type-other-1"><ul><li>位图，是一段二级制串，可以通过最小的单位bit来设置元素的状态，特别适合一些数据量大且使用二值统计的场景，底层由String类型实现</li><li><strong>应用场景</strong><ul><li>签到统计</li><li>判断用户的登录状态</li></ul></li></ul></div><div class="tab-pane" id="redis-data-type-other-2"><ul><li>一种用于统计基数的数据集合类型，即统计一个集合中不重复的元素个数，其优点是在输入元素的数量或者体积非常非常大时，计算基数所需的内存空间总是固定的、并且是很小的，但是缺点是存在误差，约为0.81%</li><li><strong>应用场景</strong><ul><li>百万级网页UV计数</li></ul></li></ul></div><div class="tab-pane" id="redis-data-type-other-3"><ul><li>用于存储地理位置信息，即经纬度信息，底层使用ZSet实现</li><li>应用场景<ul><li>滴滴打车<ul><li>先存入车辆的经纬度，当乘客打车时查找乘客经纬度5km内的车辆信息</li></ul></li></ul></li></ul></div><div class="tab-pane" id="redis-data-type-other-4"><ul><li>用于实现消息队列</li></ul></div></div></div>
              </div>
            </details>

<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-redis-data-structure"><ul class="nav-tabs"><li class="tab active"><a class="#redis-data-structure-1">SDS</a></li><li class="tab"><a class="#redis-data-structure-2">压缩列表</a></li><li class="tab"><a class="#redis-data-structure-3">哈希表</a></li><li class="tab"><a class="#redis-data-structure-4">跳表</a></li><li class="tab"><a class="#redis-data-structure-5">quicklist</a></li><li class="tab"><a class="#redis-data-structure-6">listpack</a></li></ul><div class="tab-content"><div class="tab-pane active" id="redis-data-structure-1"><ul><li>对比C语言中的字符串来说，其主要增加了len和alloc两个字段，即长度和容量，这么做有以下好处：<ul><li>获取字符串的长度的时间复杂度为O1，直接通过len获取即可</li><li>因为有len来记录长度，也就不用使用‘\0’来作为字符串的结束标志，所以Redis中的字符串可以存储任意格式的二进制数据，保证了二进制安全</li><li>对字符串进行修改时，可以通过alloc-len来判断缓冲区是否会溢出，如果会溢出，Redis将自动扩大SDS的空间大小</li></ul></li></ul></div><div class="tab-pane" id="redis-data-structure-2"><ul><li>顾名思义，压缩列表是 Redis 为了节约内存而开发的，其结构类似于数组，但每个元素的长度可变</li><li>压缩列表的结构<ul><li><strong>zlbytes</strong>：整个压缩列表的总字节数</li><li><strong>zltail</strong>：尾节点相对于起始地址的偏移量，用于快速定位尾部</li><li><strong>zllen</strong>：列表中entry（条目）的数量</li><li><strong>entry</strong>：实际存储的数据，每个entry大小动态变化</li><li><strong>zlend</strong>：结束标志，固定为0xFF</li></ul></li><li>每个条目包含三个部分<ul><li><strong>prevlen</strong>：记录了前一个节点的长度，用来反向遍历</li><li><strong>encoding</strong>：记录了数据的类型和长度</li><li><strong>data</strong>：记录了实际数据</li></ul></li><li>缺点是查找效率较低，且存在连锁更新的问题，Redis7.0后逐步引入listpack取代压缩列表<ul><li>连锁更新<ul><li>因为entry中prevlen字段是变长编码的，修改一个条目时，该条目长度的变化可能导致其后一个条目的prevlen字段变化，导致条目长度也随之变化，又因为内存是连续的，后续的条目可能都需要移动来适应这个变化，由此引发连锁更新</li><li>因为连锁更新出现的情况并不多见，所以prevlen使用变长编码设计带来的内存优化收益更高</li></ul></li></ul></li></ul><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/Redis-ziplist.png"
                      alt="Redis-ziplist"
                ></p></div><div class="tab-pane" id="redis-data-structure-3"><ul><li>Redis在实际使用哈希表时，定义了一个dict结构体，里面包含两个哈希表，这是哈希扩容的基础（rehash）</li><li>正常服务请求阶段，插入的数据都会写入到哈希表1，哈希表2并没有分配空间，随着数据增多，触发扩容条件，扩容过程分三步：<ul><li>首先给哈希表2分配空间，一般是哈希表1的两倍大小</li><li>然后将哈希表1的数据迁移到哈希表2中<ul><li>为避免一次性全量数据迁移引起性能抖动，扩容过程是渐进式的</li><li>每次对哈希表元素进行操作时，Redis除了完成对应操作之外，还会推进扩容进程，将哈希表1的元素映射到哈希表2上</li><li>随着处理的请求增多，最终在某一时刻完全完成数据迁移</li></ul></li><li>迁移完成后，哈希表1的空间被释放，并吧哈希表2设置为哈希表1，然后重新创建一个空白的哈希表2，为下次扩容做准备</li></ul></li><li>扩容触发条件<ul><li><code>负载因子=哈希表中的元素个数/哈希表的大小</code></li><li>当负载因子大于1，且Redis此时没有进行持久化操作时，会触发扩容</li><li>当负载因子大于5时，说明哈希冲突非常严重了，会强制触发哈希扩容</li></ul></li><li>扩容过程中如果有读请求，会先到哈希表1中查找，如果没找到再到哈希表2中查找</li></ul></div><div class="tab-pane" id="redis-data-structure-4"><ul><li>跳表是在链表的基础上改进过来的，其增加了多级索引，是一种多层级的有序链表，作用上可以简单理解为支持二分查找的双向链表，数据量很大时，跳表的时间复杂度就是O(logn)</li><li>因为有高度的限制，Redis中最高为64层，所以其空间复杂度为O(n)</li><li>跳表在检索数据时会从高层级的链表往低层级的链表检索，层级越高，每次跨越的节点数越多</li><li>Redis实现的跳表中每个节点的层级是随机的，在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</li></ul><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/Redis-skiplist.png"
                      alt="Redis-skiplist"
                ></p><blockquote><p><em><strong>Tip</strong></em></p><p>为什么使用跳表而不是红黑树或者B+树？</p><ul><li>对比红黑树<ul><li>查找性能上跳表和红黑树差不多</li><li>进行插入和删除操作时，红黑树可能需要平衡调整，逻辑复杂，而跳表只需要修改相邻节点的指针就行了，方便快速</li><li>进行范围查找时，跳表的效率更高，红黑树的范围查找需要通过中序遍历来实现，过程比较复杂，而跳表只需要找到最小值后顺序遍历就行了</li><li>此外，从算法实现难度上来说，跳表比红黑树要简单得多</li></ul></li><li>对比B+树<ul><li>跳表操作更简单，实现难度更低</li><li>B+树更加契合磁盘io读取数据地场景，在MySQL中更适用，而Redis是基于内存的，不需要磁盘io</li></ul></li></ul></blockquote></div><div class="tab-pane" id="redis-data-structure-5"><ul><li>实际上就是压缩列表+双向链表</li><li>链表中每个节点都包含一个指向压缩链表的指针，通过控制每个压缩列表大小或者元素个数，尽可能减少连锁更新带来的问题</li></ul><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/Redis-quicklist.png"
                      alt="Redis-quicklist"
                ></p></div><div class="tab-pane" id="redis-data-structure-6"><ul><li>因为快表依然存在连锁更新的问题，所以在Redis 5.0新设计了一个数据结构listpack来替代压缩列表，彻底解决了连锁更新的问题</li><li>listpack的结构<ul><li><strong>total_bytes</strong>：整个listpack的字节数</li><li><strong>num_elements</strong>：元素个数</li><li><strong>entry</strong>：条目，即实际存储的数据</li><li><strong>end</strong>：结束标志</li></ul></li><li>每个条目包含三部分<ul><li><strong>encoding</strong>：记录了数据的类型和长度</li><li><strong>data</strong>：记录了实际数据</li><li><strong>len</strong>：记录了当前条目encoding+data的总长度</li></ul></li><li>其最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患，现在每个节点只存储自己的长度，也就解决了这个问题</li></ul><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/Redis-listpack.png"
                      alt="Redis-listpack"
                ></p></div></div></div>
              </div>
            </details>

<h2 id="如何实现Redis原子性"><a href="#如何实现Redis原子性" class="headerlink" title="如何实现Redis原子性"></a>如何实现Redis原子性</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>使用Lua脚本，将多个操作写到一个Lua脚本中，Redis会把整个Lua脚本当作一个操作执行，以此来保证原子性</li><li>值得注意的是，Redis本身也有事务相关的命令，使用MULTI和EXEC可以开启和提交一个事务，但是这个所谓的事物并不能完全保证命令的原子性，因为如果事物执行过程中出现错误，Redis无法进行回滚</li></ul>
              </div>
            </details>

<h1 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h1><h2 id="Redis有哪些持久化机制"><a href="#Redis有哪些持久化机制" class="headerlink" title="Redis有哪些持久化机制"></a>Redis有哪些持久化机制</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-redis-persistence"><ul class="nav-tabs"><li class="tab active"><a class="#redis-persistence-1">AOF日志</a></li><li class="tab"><a class="#redis-persistence-2">RDB快照</a></li><li class="tab"><a class="#redis-persistence-3">混合持久化</a></li></ul><div class="tab-content"><div class="tab-pane active" id="redis-persistence-1"><ul><li><strong>核心思路</strong><ul><li>每执行一条<strong>写操作</strong>命令，就把该命令以追加的方式写入到一个文件里</li></ul></li><li><strong>优点</strong><ul><li>使用AOF日志持久化可以较大程度保证数据安全性，因为它默认每接收到一个写命令就会追加到文件末尾，即使Redis服务器宕机，也只会丢失最后一次写入前的数据</li></ul></li><li><strong>缺点</strong><ul><li>因为记录了每一次操作，所以AOF文件通常比较大，而且频繁的io会对Redis性能造成影响</li><li>通过AOF恢复数据时，因为要重新执行所有命令，速度较慢</li></ul></li><li><strong>三种写回策略</strong><ul><li>Always<ul><li>每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘</li></ul></li><li>Everysec<ul><li>每次写操作命令执行完后，先将命令写入到 AOF文件的内核缓冲区，然后每隔一秒会有一个异步的线程将缓冲区里的内容写回到硬盘</li></ul></li><li>No<ul><li>不由 Redis 控制写回硬盘的时机，即每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘</li></ul></li></ul></li></ul><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/Redis-AOF.png"
                      alt="Redis-AOF"
                ></p></div><div class="tab-pane" id="redis-persistence-2"><ul><li><strong>核心思路</strong><ul><li>将某一时刻的内存数据，以二进制的方式写入磁盘</li></ul></li><li><strong>优点</strong><ul><li>文件体积小，备份和恢复的速度非常快</li></ul></li><li><strong>缺点</strong><ul><li>RDB方式在两次快照之间，如果Redis服务器发生故障，这段时间的数据将会丢失</li></ul></li></ul></div><div class="tab-pane" id="redis-persistence-3"><ul><li><strong>核心思路</strong><ul><li>将RDB文件的内容和增量的AOF日志文件存在一起，AOF日志不再记录全量的日志，而是RDB久化开始 到RDB持久化结束的这段时间发生的增量AOF日志，通常这部分AOF日志很小</li></ul></li><li><strong>优点</strong><ul><li>重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样加载的时候速度会很快</li><li>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这样在保存RDB快照期间，Redis宕机丢失的数据更少</li></ul></li></ul></div></div></div>
              </div>
            </details>

<h2 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>为什么要有重写机制</strong><ul><li>为了避免 AOF 文件越写越大，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件</li></ul></li><li><strong>如何进行重写</strong><ul><li>Redis会读取当前数据库中所有的键值对，然后将每一个键值对用一条命令记录到<strong>新的AOF文件</strong>中，等到全部记录完后，用新的AOF文件替换掉旧的AOF文件即可</li><li>这个过程有点类似于RDB快照，只是RDB记录的是二进制数据，而AOF记录的是Redis命令</li></ul></li><li><strong>为什么不直接覆写现有的AOF文件</strong><ul><li>为避免AOF重写过程中出现错误，重写失败，导致现有AOF文件被污染</li><li>写到新的AOF文件中，即使出现错误，直接删掉这个AOF文件即可</li></ul></li></ul>
              </div>
            </details>

<h2 id="执行AOF重写或RDB快照时，数据可以被修改吗"><a href="#执行AOF重写或RDB快照时，数据可以被修改吗" class="headerlink" title="执行AOF重写或RDB快照时，数据可以被修改吗"></a>执行AOF重写或RDB快照时，数据可以被修改吗</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>结论</strong><ul><li>可以被修改</li></ul></li><li><strong>原因</strong><ul><li>执行AOF重写或RDB快照时，都会通过<code>fork()</code>创建子进程来进行处理，此时子进程和父进程还是共享同一片内存数据，只有在发生修改内存数据的情况时，被影响的内存块才会被复制一份，以此减少创建子进程时的性能损耗</li><li>创建子进程后，如果主线程（父进程）执行的是读操作，那么父进程和子进程之间互不影响，内存数据不会发生变动</li><li>如果执行的是写操作，那么被修改的内存数据所在的内存块就会复制一份，主线程在这个复制的内存块中进行修改操作，而原本的内存数据不受影响，子进程保存的依然是原内存数据</li></ul></li></ul>
              </div>
            </details>

<h2 id="大Key对持久化的影响"><a href="#大Key对持久化的影响" class="headerlink" title="大Key对持久化的影响"></a>大Key对持久化的影响</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>对AOF的影响<ul><li>使用Always策略时，每次执行完命令后，主线程将命令写入AOF文件并立即刷入磁盘，如果写入的是一个大key，这个过程会非常耗时，导致主线程出现阻塞，影响后续命令执行</li><li>使用Everysec策略时，因为刷盘操作是一个异步线程在处理，所以大Key持久化的过程不会影响到主线程</li><li>使用No策略时，Redis不控制刷盘时机，所以也不会对主线程产生影响</li></ul></li><li>对RDB的影响<ul><li>执行RDB快照会使用<code>fork()</code>创建一个子进程来处理，虽然<code>fork()</code>不会在创建子进程时直接复制父进程的物理内存，但是会复制父进程的页表</li><li>页表是用来维护虚拟内存和物理内存之间的映射关系的，大key的数量越多，那么其在物理内存中占据的内存块也越多，那么对应的页表就会越大</li><li>页表越大那么执行<code>fork()</code>复制页表时阻塞的时间就越长，导致Redis性能变差</li></ul></li></ul><blockquote><p><em><strong>Tip</strong></em></p><p>执行AOF重写时也会触发<code>fork()</code>，所以大key对AOF重写也有影响，最终也会导致Redis性能变差</p></blockquote>
              </div>
            </details>

<h1 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h1><h2 id="Redis是单线程吗"><a href="#Redis是单线程吗" class="headerlink" title="Redis是单线程吗"></a>Redis是单线程吗</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>严格来说，它是<strong>单线程为主，部分环节用多线程优化</strong></li><li>Redis的核心命令执行是单线程的，依赖I&#x2F;O多路复用实现高并发，这避免了锁竞争和高开销</li><li>从6.0开始，它引入了多线程I&#x2F;O来处理网络读写，提升了大规模连接的性能，但执行命令依然是单线程</li></ul><blockquote><p><em><strong>Tip</strong></em></p><p>Redis执行命令为什么使用单线程——Redis是基于内存的，cpu不会成为Redis性能上的瓶颈，最有可能影响其性能的是机器内存和网络带宽，考虑到这一点，再加上单线程实现起来比较容易，Redis也就使用了单线程</p></blockquote>
              </div>
            </details>

<h2 id="Redis哪些地方使用了多线程"><a href="#Redis哪些地方使用了多线程" class="headerlink" title="Redis哪些地方使用了多线程"></a>Redis哪些地方使用了多线程</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>关闭文件</li><li>AOF刷盘</li><li>释放内存</li><li>处理网络请求</li></ul>
              </div>
            </details>

<h1 id="Redis内存管理"><a href="#Redis内存管理" class="headerlink" title="Redis内存管理"></a>Redis内存管理</h1><h2 id="Redis过期删除策略"><a href="#Redis过期删除策略" class="headerlink" title="Redis过期删除策略"></a>Redis过期删除策略</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>Redis选择<strong>惰性删除+定期删除</strong>两种策略配合使用<ul><li>针对惰性删除，Redis在访问或修改key时，先检查该key是否过期，如果过期则删除该key，并返回null，否则返回正常的键值对</li><li>针对定期删除，Redis从过期字典中随机抽取20个key，删除其中过期的key，如果删除的数量超过25%，则重复该过程，直到删除数量少于25%，才等待下一轮的定期删除</li></ul></li><li><strong>三种常见的过期删除策略</strong></li></ul><div class="tabs" id="tab-redis-delete-expire"><ul class="nav-tabs"><li class="tab active"><a class="#redis-delete-expire-1">定时删除</a></li><li class="tab"><a class="#redis-delete-expire-2">惰性删除</a></li><li class="tab"><a class="#redis-delete-expire-3">定期删除</a></li></ul><div class="tab-content"><div class="tab-pane active" id="redis-delete-expire-1"><ul><li><strong>策略</strong><ul><li>在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作</li></ul></li><li><strong>优点</strong><ul><li>可以保证过期 key 会被尽快删除，内存可以被尽快地释放</li></ul></li><li><strong>缺点</strong><ul><li>在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU，会对服务器的响应时间和吞吐量造成影响</li></ul></li></ul></div><div class="tab-pane" id="redis-delete-expire-2"><ul><li><strong>策略</strong><ul><li>不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key</li></ul></li><li><strong>优点</strong><ul><li>只在访问时检查是否过期，使用很少的系统资源</li></ul></li><li><strong>缺点</strong><ul><li>过期的key长时间不被访问就会一直留在内存中，造成内存浪费</li></ul></li></ul></div><div class="tab-pane" id="redis-delete-expire-3"><ul><li><strong>策略</strong><ul><li>每隔一段时间随机从数据库中取出一定数量的 key 进行检查，并删除其中过期的key</li></ul></li><li><strong>优点</strong><ul><li>通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用</li></ul></li><li><strong>缺点</strong><ul><li>难以确定删除操作执行的时长和频率</li></ul></li></ul></div></div></div>
              </div>
            </details>

<h2 id="Redis内存淘汰策略"><a href="#Redis内存淘汰策略" class="headerlink" title="Redis内存淘汰策略"></a>Redis内存淘汰策略</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-redis-memory-outdated"><ul class="nav-tabs"><li class="tab active"><a class="#redis-memory-outdated-1">不进行数据淘汰</a></li><li class="tab"><a class="#redis-memory-outdated-2">进行数据淘汰</a></li></ul><div class="tab-content"><div class="tab-pane active" id="redis-memory-outdated-1"><ul><li>当运行内存超过最大设置内存时，不淘汰任何数据</li><li>如果有新的数据写入，会报错通知禁止写入</li><li>单纯的查询或删除操作依然可以正常运行</li></ul></div><div class="tab-pane" id="redis-memory-outdated-2"><ul><li>在<strong>会过期的数据</strong>中进行淘汰<ul><li>随机淘汰</li><li>优先淘汰更早过期的数据</li><li>LRU（最久未使用）</li><li>LFU（最少使用）</li></ul></li><li>在<strong>所有数据范围内</strong>进行淘汰<ul><li>随机淘汰</li><li>LRU（最久未使用）</li><li>LFU（最少使用）</li></ul></li></ul></div></div></div>
              </div>
            </details>

<h1 id="高可用相关"><a href="#高可用相关" class="headerlink" title="高可用相关"></a>高可用相关</h1><h2 id="Redis如何实现高可用"><a href="#Redis如何实现高可用" class="headerlink" title="Redis如何实现高可用"></a>Redis如何实现高可用</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-high-availability"><ul class="nav-tabs"><li class="tab active"><a class="#high-availability-1">主从复制模式</a></li><li class="tab"><a class="#high-availability-2">Sentinel哨兵模式</a></li><li class="tab"><a class="#high-availability-3">Cluster集群模式</a></li></ul><div class="tab-content"><div class="tab-pane active" id="high-availability-1"><ul><li>将数据备份到其他服务器上，并且让这些机器也能对外提供服务</li><li>一般采用读写分离的方式，主服务器可以进行读写操作，而从服务器对外是只读的</li><li>从服务器数据的更新需要和主服务器进行同步</li></ul><blockquote><p><em><strong>Tip</strong></em></p><p>如果从服务器太多的话，主服务器可能会因为一直忙于和从服务器进行数据同步而影正常命令的执行，所以从服务器也可以有自己的从服务器，它不仅可以接收主服务器的同步数据，自己也可以作为主服务器将数据同步给自己的从服务器，以此来分摊主服务器的压力</p></blockquote><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/redis-master-slave.png"
                      alt="Redis-master-slave"
                ></p></div><div class="tab-pane" id="high-availability-2"><ul><li>主从模式中如果主节点挂了，就无法处理客户端的写操作请求了，这时可以引入哨兵机制实现主从节点的故障转移</li><li>哨兵是一个独立的进程，主要负责三件事<ul><li>监控：通过ping-pong请求响应检测主&#x2F;从节点是否存活</li><li>选主：如果主节点挂了，哨兵需要推选出一个新的主节点</li><li>通知：将主节点的变更信息通知给客户端和其他从节点</li></ul></li><li>一般以哨兵集群的方式部署，且哨兵节点的数量不小于三个</li></ul><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/redis-sentinel.png"
                      alt="Redis-sentinel"
                ></p></div><div class="tab-pane" id="high-availability-3"><ul><li>集群模式主要用来解决大量数据存储内存不足的问题</li><li>它将数据分片存储在不同的服务器上，以此降低系统对单主节点的依赖，达到了一个去中心化的效果</li><li>每个主节点都至少有一个从节点进行数据备份，如果某个主节点故障，对应的从节点会自动升级为主节点</li></ul><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/redis-cluster.png"
                      alt="Redis-cluster"
                ></p></div></div></div>
              </div>
            </details>

<h2 id="主从复制是如何实现的"><a href="#主从复制是如何实现的" class="headerlink" title="主从复制是如何实现的"></a>主从复制是如何实现的</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-master-slave"><ul class="nav-tabs"><li class="tab active"><a class="#master-slave-1">全量复制</a></li><li class="tab"><a class="#master-slave-2">基于长连接的命令传播</a></li><li class="tab"><a class="#master-slave-3">增量复制</a></li></ul><div class="tab-content"><div class="tab-pane active" id="master-slave-1"><ul><li>主从服务器第一次同步时使用</li><li>过程<ol><li>首先我们在从服务器执行<code>replicaof</code>命令，并指定主服务器的ip和端口</li><li>从服务器会向主服务器发送<code>psync</code>同步命令</li><li>主服务器接受到同步请求后，会发送<code>fullresync</code>响应命令，告诉从服务器接下来要进行的是全量复制</li><li>主服务器执行<code>bgsave</code>命令生成RDB快照并发送给从服务器</li><li>从服务器接收到RDB快照后会清空当前的数据，然后载入RDB文件</li><li>主服务器在生成快照到从服务器载入快照期间的写操作会写入到一个缓冲区中</li><li>等到从服务器完成载入后，主服务器会将缓冲区中的写操作发送给从服务器</li><li>从服务器执行完命令后，初次同步就完成了</li></ol></li></ul></div><div class="tab-pane" id="master-slave-2"><ul><li>主从服务器在完成第一次同步后，双方之间就会维护一个TCP连接</li><li>后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令</li><li>通过使用长连接的方式，避免频繁的 TCP 连接和断开带来的性能开销</li></ul></div><div class="tab-pane" id="master-slave-3"><ul><li>如果主从服务器间的网络连接断开了，在网络重新恢复正常之前，主服务器会将期间的写操作写入到一个环形缓冲区中</li><li>等到网络恢复正常，从服务器重新发起同步请求，主服务器就会根据从服务器的复制进度，在环形缓冲区中寻找差异的数据发送给从服务器</li><li>如果环形缓冲区中的数据已经发生覆盖，那么主服务器就会采用全量复制的方式进行同步</li></ul></div></div></div>
              </div>
            </details>

<h2 id="哨兵机制是如何实现的"><a href="#哨兵机制是如何实现的" class="headerlink" title="哨兵机制是如何实现的"></a>哨兵机制是如何实现的</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>首先哨兵节点之间可以通过Redis的发布&#x2F;订阅机制相互感知和连接，组成哨兵集群，并且可以通过<code>info</code>命令从主服务器获取从服务器的信息，也就能和从服务器建立连接并监控了</li><li>如果哨兵集群中某个哨兵判定主节点主观下线，该哨兵就会和其他哨兵进行通信，发起投票来判定主节点是否真正下线，当赞同票数达到一个阈值后，该哨兵就会将主节点标记为客观下线</li><li>当某个哨兵判断主节点客观下线后，该哨兵会发起第二轮投票，告诉其他哨兵他想成为leader，当他拿到的赞成票超过一半并且大于配置文件中的阈值时，leader选举成功</li><li>选举出哨兵leader后，就可以开始故障转移了，包含四个步骤：<ul><li>首先哨兵会从主服务器直接下属的从服务器中挑选一个从服务器，发送<code>slaveof no one</code>命令，让他成为新的主服务器。选择从服务器的规则：<ul><li>过滤掉下线的和历史连接状态不好的从服务器</li><li>从剩下的从服务器中依次比较优先级、数据完整性、机器id号选择一个胜出的从服务器</li></ul></li><li>选出新主节点后，哨兵会发送<code>slaveof</code>命令让旧主节点的下属从节点指向新的主节点</li><li>然后哨兵会通过发布&#x2F;订阅机制，发布新主节点的ip和端口信息，订阅了哨兵提供的频道的客户端就可以知道主节点发生了变更</li><li>最后哨兵会继续监视旧主节点，当它重新上线后将其设置为新主节点的从节点</li></ul></li></ul>
              </div>
            </details>

<h2 id="Cluster集群模式是如何实现的"><a href="#Cluster集群模式是如何实现的" class="headerlink" title="Cluster集群模式是如何实现的"></a>Cluster集群模式是如何实现的</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>Cluster集群采用哈希槽的方式来处理数据和节点之间的映射关系，一个集群共有<strong>16384</strong>个哈希槽，每个键值对会根据其key值不同映射到不同的哈希槽，映射过程：<ul><li>首先通过CRC16算法计算得到key的一个16bit的值</li><li>再用这个值对16384进行取模，得到对应哈希槽的下标</li></ul></li><li>而哈希槽到Redis节点的映射有两种处理方式<ul><li>平均分配：创建集群时，Redis会根据集群主节点的数量，将哈希槽平均映射到这些主节点</li><li>手动分配：将16384个哈希槽手动分配给集群主节点，且一定要全部分配完，否则无法集群模式无法正常工作</li></ul></li><li>客户端向Redis集群中任一节点发送请求时，集群会根据key的哈希值路由到对应的节点进行响应</li></ul>
              </div>
            </details>

<h2 id="如何应对主从数据不一致"><a href="#如何应对主从数据不一致" class="headerlink" title="如何应对主从数据不一致"></a>如何应对主从数据不一致</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>因为主从数据同步是异步进行的，所以无法实现两者的强一致性，只能尽量减少数据不一致情况的发生</li><li><strong>应对方法</strong><ul><li>尽量保证主从节点间的网络连接状况良好，避免主从节点在不同的机房</li><li>开发一个外部程序来监控主从服务器之间的复制进度，如果两者之间的复制进度差值过大，可以让客户端不在从这个从服务器中获取数据</li></ul></li></ul>
              </div>
            </details>

<h2 id="如何应对集群脑裂导致数据丢失"><a href="#如何应对集群脑裂导致数据丢失" class="headerlink" title="如何应对集群脑裂导致数据丢失"></a>如何应对集群脑裂导致数据丢失</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>脑裂现象</strong><ul><li>当主服务器与其所有从服务器都失联了，但是与客户端的连接又是正常的，某个从节点经投票后成为新的主节点，开始接收新的数据写入，但这个新主节点出现之前的数据依然写入到了旧主节点，等到网络恢复正常后，旧主节点被降级为从节点，就会向新的主节点发起同步请求，旧主节点会进行全量复制，清空自己的本地数据，那么之前写入的数据就丢失了</li></ul></li><li><strong>解决方案</strong><ul><li>当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么就禁止主节点进行数据的写入操作，直接把错误返回给客户端，等到新主节点上线，数据会直接写入到新主节点中，也就不会产生数据丢失的问题了</li></ul></li></ul>
              </div>
            </details>

<h1 id="场景实践"><a href="#场景实践" class="headerlink" title="场景实践"></a>场景实践</h1><h2 id="Redis如何实现分布式锁"><a href="#Redis如何实现分布式锁" class="headerlink" title="Redis如何实现分布式锁"></a>Redis如何实现分布式锁</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>加锁</strong><ul><li>使用<code>SET key value NX EX 10</code>命令<ul><li>key是锁的名称</li><li>value是锁的唯一标识，一般使用uuid，保证释放的是自己的锁</li><li>NX表示仅当key不存在时才设置，防止覆盖</li><li>EX设置锁的过期时间，防止死锁</li></ul></li></ul></li><li><strong>释放锁</strong><ul><li>因为要保证释放的是自己的锁，所以要先执行<code>GET</code>进行校验，校验成功后使用<code>DEL</code>删除key</li><li>一般使用Lua脚本执行，保证<code>GET</code>和<code>DEL</code>是原子操作</li></ul></li><li><strong>高可用场景</strong><ul><li>在集群模式下，使用RedLock算法来保证更高的可靠性</li><li>原理<ul><li>依次向多个Redis节点请求加锁，并且使用相同的key和value</li><li>如果超过半数节点加锁成功，则认为是加锁成功</li><li>如果加锁失败或超时，需要在所有已加锁的节点释放锁</li></ul></li></ul></li></ul><blockquote><p><em><strong>Tip</strong></em></p><p>没有唯一标识导致误删锁的场景——</p><ol><li>线程A获取到锁，但业务执行时间较长</li><li>锁的过期时间到了，Redis自动释放锁</li><li>线程B重新获取到锁，开始执行自己的业务逻辑</li><li>线程A业务此时执行完毕，执行<code>DEL</code>命令释放锁</li><li>线程B失去锁的保护，数据可能被其他线程修改，产生数据不一致的问题</li></ol></blockquote>
              </div>
            </details>

<h2 id="大Key问题和解决办法"><a href="#大Key问题和解决办法" class="headerlink" title="大Key问题和解决办法"></a>大Key问题和解决办法</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>什么是大Key</strong><ul><li>某个key对应的value值所占的内存空间比较大</li></ul></li><li><strong>大Key有什么问题</strong><ul><li><strong>内存占用过高</strong>，进而触发内存淘汰策略，极端情况下甚至会耗尽内存导致Redis实例崩溃</li><li><strong>性能下降</strong>，操作大key可能导致Redis主线程阻塞</li><li><strong>网络拥塞</strong>，每次获取大key产生的网络流量较大，消耗服务器的带宽</li><li><strong>主从同步延迟</strong>，传输大key的过程比较耗时，这会导致Redis主从同步的网络延迟增加，影响数据一致性</li></ul></li><li><strong>解决办法</strong><ul><li><strong>对大key进行拆分</strong>，确保每个key的成员数量在合理的范围内</li><li><strong>对大key进行清理</strong>，设计定期清理的机制，通过脚本或定时任务，定期检查和清理大key</li></ul></li></ul>
              </div>
            </details>

<h2 id="热Key问题和解决办法"><a href="#热Key问题和解决办法" class="headerlink" title="热Key问题和解决办法"></a>热Key问题和解决办法</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>什么是热key</strong><ul><li>访问频率极高的key</li></ul></li><li><strong>热key有什么问题</strong><ul><li>单点压力过大，可能导致Redis宕机</li></ul></li><li><strong>如何发现热key</strong><ul><li>根据业务经验，预测哪些key有可能成为热key</li><li>使用相关检测工具，如Redis的<code>monitor</code>命令，实时监控Redis命令执行情况，可以找到访问频率较高的key</li></ul></li><li><strong>如何解决热key问题</strong><ul><li>利用二级缓存<ul><li>在程序中对热key进行本地缓存，防止请求打到Redis</li></ul></li><li>备份热key<ul><li>在多个reids中将热key进行备份，分摊单点热key的数据压力</li></ul></li></ul></li></ul>
              </div>
            </details>

<h2 id="缓存雪崩、击穿、穿透"><a href="#缓存雪崩、击穿、穿透" class="headerlink" title="缓存雪崩、击穿、穿透"></a>缓存雪崩、击穿、穿透</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-redis-memory-3problem"><ul class="nav-tabs"><li class="tab active"><a class="#redis-memory-3problem-1">缓存雪崩</a></li><li class="tab"><a class="#redis-memory-3problem-2">缓存击穿</a></li><li class="tab"><a class="#redis-memory-3problem-3">缓存穿透</a></li></ul><div class="tab-content"><div class="tab-pane active" id="redis-memory-3problem-1"><ul><li><strong>概念</strong><ul><li>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机，造成数据库压力骤增</li></ul></li><li><strong>解决办法</strong><ul><li>给key的过期时间加上一个随机值，避免大量key同时失效</li><li>如果是Redis宕机引起的，需要部署Redis集群，做高可用</li></ul></li></ul></div><div class="tab-pane" id="redis-memory-3problem-2"><ul><li><strong>概念</strong><ul><li>某个热点数据过期，大量请求直接打到数据库</li></ul></li><li><strong>解决办法</strong><ul><li>使用互斥锁，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值</li><li>热点数据设置永不过期，或者过期后在后台异步重新构建缓存并设置过期时间</li></ul></li></ul></div><div class="tab-pane" id="redis-memory-3problem-3"><ul><li><strong>概念</strong><ul><li>查询一个缓存和数据库中都不存在的key，所有这样的请求都会直接访问数据库，且不能构建缓存</li></ul></li><li><strong>解决办法</strong><ul><li>参数校验，拦截一些非法的恶意请求</li><li>缓存空对象，如果数据库中不存在查询对象，则在缓存中缓存一个空对象</li><li>使用布隆过滤器判断key是否可能存在</li></ul></li></ul></div></div></div>
              </div>
            </details>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/Algorthm/sort-algorthm/</url>
    <content><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BubbleSort 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		notSwap := <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="built_in">len</span>(nums) - <span class="number">1</span>; j &gt; i; j-- &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[j] &lt; nums[j<span class="number">-1</span>] &#123;</span><br><span class="line">				notSwap = <span class="literal">false</span></span><br><span class="line">				nums[j], nums[j<span class="number">-1</span>] = nums[j<span class="number">-1</span>], nums[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> notSwap &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SelectSort 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		selected := i</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[j] &lt; nums[selected] &#123;</span><br><span class="line">				selected = j</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		nums[i], nums[selected] = nums[selected], nums[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InsertSort 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i; j &gt; <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j<span class="number">-1</span>]; j-- &#123;</span><br><span class="line">			nums[j<span class="number">-1</span>], nums[j] = nums[j], nums[j<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ShellSort 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShellSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> gap := <span class="built_in">len</span>(nums) / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := gap; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">			<span class="keyword">for</span> j := i; j &gt;= gap &amp;&amp; nums[j-gap] &gt; nums[j]; j -= gap &#123;</span><br><span class="line">				nums[j-gap], nums[j] = nums[j], nums[j-gap]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MergeSort 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">	MergeSort(nums, left, mid)</span><br><span class="line">	MergeSort(nums, mid+<span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">	p1, p2, p3 := left, mid+<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">	temp := <span class="built_in">make</span>([]<span class="type">int</span>, right-left+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> p1 &lt;= mid &amp;&amp; p2 &lt;= right &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[p1] &lt; nums[p2] &#123;</span><br><span class="line">			temp[p3] = nums[p1]</span><br><span class="line">			p1++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			temp[p3] = nums[p2]</span><br><span class="line">			p2++</span><br><span class="line">		&#125;</span><br><span class="line">		p3++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> p1 &lt;= mid &#123;</span><br><span class="line">		temp[p3] = nums[p1]</span><br><span class="line">		p3++</span><br><span class="line">		p1++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> p2 &lt;= right &#123;</span><br><span class="line">		temp[p3] = nums[p2]</span><br><span class="line">		p3++</span><br><span class="line">		p2++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> temp &#123;</span><br><span class="line">		nums[left+i] = temp[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// QuickSort 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	length := right - left + <span class="number">1</span></span><br><span class="line">	x := rand.Int() % length</span><br><span class="line">	nums[right], nums[left+x] = nums[left+x], nums[right]</span><br><span class="line">	pivot := nums[right]</span><br><span class="line"></span><br><span class="line">	l, r := left, right</span><br><span class="line">	<span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">		<span class="keyword">for</span> l &lt; r &amp;&amp; nums[l] &lt;= pivot &#123;</span><br><span class="line">			l++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line">			nums[r] = nums[l]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> l &lt; r &amp;&amp; nums[r] &gt; pivot &#123;</span><br><span class="line">			r--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> l &lt; r &#123;</span><br><span class="line">			nums[l] = nums[r]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	nums[l] = pivot</span><br><span class="line"></span><br><span class="line">	QuickSort(nums, left, l<span class="number">-1</span>)</span><br><span class="line">	QuickSort(nums, r+<span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HeapSort 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	buildMaxHeap(nums)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">		nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">		heapify(nums, <span class="number">0</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildMaxHeap</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(nums)/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		heapify(nums, i, <span class="built_in">len</span>(nums))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(nums []<span class="type">int</span>, i <span class="type">int</span>, length <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i &lt; length &#123;</span><br><span class="line">		left := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">		right := <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">		largest := i</span><br><span class="line">		<span class="keyword">if</span> left &lt; length &amp;&amp; nums[largest] &lt; nums[left] &#123;</span><br><span class="line">			largest = left</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> right &lt; length &amp;&amp; nums[largest] &lt; nums[right] &#123;</span><br><span class="line">			largest = right</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> largest == i &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		nums[largest], nums[i] = nums[i], nums[largest]</span><br><span class="line">		i = largest</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CountingSort 计数排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountingSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    maxNum := math.MinInt</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">       maxNum = max(maxNum, num)</span><br><span class="line">    &#125;</span><br><span class="line">    counter := <span class="built_in">make</span>([]<span class="type">int</span>, maxNum+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">       counter[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= maxNum; i++ &#123;</span><br><span class="line">       counter[i] += counter[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">       result[counter[num]<span class="number">-1</span>] = num</span><br><span class="line">       counter[num]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> result &#123;</span><br><span class="line">       nums[i] = num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BucketSort 桶排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BucketSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    minNum, maxNum := math.MaxInt, math.MinInt</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">       minNum, maxNum = min(num, minNum), max(num, maxNum)</span><br><span class="line">    &#125;</span><br><span class="line">    bucketNum := (maxNum-minNum)/<span class="built_in">len</span>(nums) + <span class="number">1</span></span><br><span class="line">    buckets := <span class="built_in">make</span>([][]<span class="type">int</span>, bucketNum)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">       index := (num - minNum) / <span class="built_in">len</span>(nums)</span><br><span class="line">       buckets[index] = <span class="built_in">append</span>(buckets[index], num)</span><br><span class="line">    &#125;</span><br><span class="line">    index := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">       sort.Ints(bucket)</span><br><span class="line">       <span class="keyword">for</span> _, num := <span class="keyword">range</span> bucket &#123;</span><br><span class="line">          nums[index] = num</span><br><span class="line">          index++</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RadixSort 基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RadixSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    maxNum := math.MinInt</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">       maxNum = max(maxNum, num)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    digit := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> maxNum &gt; <span class="number">0</span> &#123;</span><br><span class="line">       digit++</span><br><span class="line">       maxNum /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buckets := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; digit; i++ &#123;</span><br><span class="line">       <span class="keyword">for</span> j, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">          num /= <span class="type">int</span>(math.Pow10(i))</span><br><span class="line">          radix := num % <span class="number">10</span></span><br><span class="line">          buckets[radix] = <span class="built_in">append</span>(buckets[radix], nums[j])</span><br><span class="line">       &#125;</span><br><span class="line">       index := <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> j, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">          <span class="keyword">for</span> _, num := <span class="keyword">range</span> bucket &#123;</span><br><span class="line">             nums[index] = num</span><br><span class="line">             index++</span><br><span class="line">          &#125;</span><br><span class="line">          buckets[j] = buckets[j][:<span class="number">0</span>]</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Algorthm</category>
      </categories>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 面试题</title>
    <url>/Interview/go-interview/</url>
    <content><![CDATA[<h1 id="Go基础"><a href="#Go基础" class="headerlink" title="Go基础"></a>Go基础</h1><h2 id="golang的特点和优势"><a href="#golang的特点和优势" class="headerlink" title="golang的特点和优势"></a>golang的特点和优势</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>语法简单</li><li>天然支持高并发</li><li>内置垃圾回收</li></ul>
              </div>
            </details>

<h2 id="golang和java对比"><a href="#golang和java对比" class="headerlink" title="golang和java对比"></a>golang和java对比</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>应用方面</strong><ul><li>Java广泛应用于大型企业应用、Android应用、大规模分布式系统和企业级应用。</li><li>Go适用于构建高性能、高并发的后端服务、网络应用、云服务以及分布式系统。</li></ul></li><li><strong>并发方面</strong><ul><li>Java通过线程和锁来处理并发。</li><li>Go语言并发特性的核心是goroutine和channel。</li></ul></li><li><strong>语言设计方面</strong><ul><li>Java是一门功能丰富、面向对象的语言，支持面向对象编程、泛型等高级特性。</li><li>Go语言的设计注重简洁和清晰，具有简单的语法和类型系统，它摒弃了一些复杂的特性，强调代码的可读性。</li></ul></li></ul>
              </div>
            </details>

<h2 id="golang数据类型"><a href="#golang数据类型" class="headerlink" title="golang数据类型"></a>golang数据类型</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>基础类型</strong><ul><li>布尔型 bool</li><li>整形 int</li><li>浮点型 float</li><li>字符串型 string</li><li>复数类型 complex</li><li>错误类型 error</li></ul></li><li><strong>复合类型</strong><ul><li>指针 pointer</li><li>数组 array</li><li>切片 slice</li><li>映射 map</li><li>通道 channel</li><li>结构体 struct</li><li>接口 interface</li><li>函数 function</li></ul></li></ul>
              </div>
            </details>

<h2 id="golang的引用类型包括哪些"><a href="#golang的引用类型包括哪些" class="headerlink" title="golang的引用类型包括哪些"></a>golang的引用类型包括哪些</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>slice</li><li>map</li><li>channel</li><li><strong>interface</strong></li></ul>
              </div>
            </details>

<h2 id="new和make的区别"><a href="#new和make的区别" class="headerlink" title="new和make的区别"></a>new和make的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>共同点</strong><ul><li>给变量分配内存&#x2F;进行初始化</li></ul></li><li><strong>不同点</strong><ul><li><strong>返回类型不同</strong><ul><li>new返回该类型的指针</li><li>make返回该类型本身</li></ul></li><li><strong>作用类型不同</strong><ul><li>new可以作用于所有类型</li><li>make只能作用于slice、map、channel</li></ul></li><li><strong>初始化方式不同</strong><ul><li>new是直接将指针所指向的内存空间清零</li><li>make可以根据变量类型来进行初始化</li></ul></li></ul></li></ul>
              </div>
            </details>

<h2 id="string和-byte的区别"><a href="#string和-byte的区别" class="headerlink" title="string和[]byte的区别"></a>string和[]byte的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>不可变性</strong><ul><li>string是不可变的数据类型，一旦创建就不能被修改。任何修改string的操作都会产生一个新的 string，而原始的string保持不变。</li><li>[]byte是可变的切片，可以通过索引直接修改切片中的元素。</li></ul></li><li><strong>内存分配</strong><ul><li>string是一个不可变的视图，底层数据是只读的，string的内存分配和释放由runtime管理</li><li>[]byte是一个可变的切片，底层数据是可以修改的，[]byte的内存管理由程序员负责</li></ul></li><li><strong>应用场景</strong><ul><li>如果需要频繁地修改字符串内容，或者处理二进制数据，使用[]byte 更为合适</li><li>如果字符串内容基本保持不变并且主要处理文本数据，那么使用 string 更为方便</li></ul></li></ul>
              </div>
            </details>

<h2 id="byte和rune的区别"><a href="#byte和rune的区别" class="headerlink" title="byte和rune的区别"></a>byte和rune的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>byte表示字节，是uint8的别名，rune表示字符，是int32的别名</li><li>byte表示ASCII码字符，rune表示Unicode字符</li><li>在遍历字符串时，如果字符串含有中文，需要使用rune</li></ul>
              </div>
            </details>

<h2 id="函数返回局部变量的指针是否安全"><a href="#函数返回局部变量的指针是否安全" class="headerlink" title="函数返回局部变量的指针是否安全"></a>函数返回局部变量的指针是否安全</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <p>和c&#x2F;cpp不同，由于go语言会进行内存逃逸分析，go语言中返回局部变量的指针是被允许的</p>
              </div>
            </details>

<h2 id="for-range时k、v的地址是否发生变化"><a href="#for-range时k、v的地址是否发生变化" class="headerlink" title="for range时k、v的地址是否发生变化"></a>for range时k、v的地址是否发生变化</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <p>不会</p>
              </div>
            </details>

<h2 id="关于defer"><a href="#关于defer" class="headerlink" title="关于defer"></a>关于defer</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>作用</strong><ul><li>起延迟执行的作用，可以用来进行资源释放和收尾工作</li></ul></li><li><strong>特点</strong><ul><li>和栈一样后进先出，先出现的defer后执行</li></ul></li><li><strong>使用场景</strong><ul><li>释放锁</li><li>关闭文件</li><li>配合recover捕获panic</li></ul></li></ul><blockquote><p><em><strong>Tip</strong></em></p><ul><li>defer后面跟有参函数时会直接在defer声明处进行参数传递</li><li>defer在retrun后执行，返回值为无名返回值时，返回值结果不会被修改；但是当返回值类型为有名返回值或指针时，返回值结果可能被修改</li></ul></blockquote>
              </div>
            </details>

<h2 id="golang参数传递"><a href="#golang参数传递" class="headerlink" title="golang参数传递"></a>golang参数传递</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>golang中所有传参都是值传递，即传入的是实际参数的副本</li><li>所以传递引用类型（如slice、map、channel）也是值传递，只是副本和实际参数引用的底层数据是相同的。比如传入切片，副本切片引用的是和原切片相同的底层数组，所以对副本进行修改操作时原切片也会受到影响</li></ul>
              </div>
            </details>

<h2 id="golang面向对象"><a href="#golang面向对象" class="headerlink" title="golang面向对象"></a>golang面向对象</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>封装</strong><ul><li>首字母大写的字段和方法是公有的，可以被其他包访问</li><li>首字母小写的字段和方法是私有的，只能在当前包中使用</li></ul></li><li><strong>继承</strong><ul><li>go使用结构体嵌套的方式实现继承，嵌入的匿名结构体称为嵌入类型</li><li>具有字段提升的特性，可以把父类型的字段和方法注入到子类型中去</li><li>另外go语言支持多重继承</li></ul></li><li><strong>多态</strong><ul><li>go通过interface来实现多态</li><li>一个类型的实例可以赋值给它所实现的任意接口</li></ul></li></ul>
              </div>
            </details>

<h2 id="如何高效拼接字符串"><a href="#如何高效拼接字符串" class="headerlink" title="如何高效拼接字符串"></a>如何高效拼接字符串</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>方式</strong><ul><li><code>+</code></li><li><code>fmt.Sprintf()</code></li><li><code>strings.Builder()</code></li><li><code>bytes.Buffer()</code></li><li><code>strings.Join()</code></li></ul></li><li><strong>性能</strong><ul><li><code>strings.Join()</code> ≈ <code>strings.Builder()</code> &gt; <code>bytes.Buffer()</code> &gt;<code>+</code>+ &gt; <code>fmt.Sprintf()</code></li></ul></li></ul>
              </div>
            </details>

<h2 id="空struct-的作用"><a href="#空struct-的作用" class="headerlink" title="空struct{}的作用"></a>空struct{}的作用</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>作用</strong><ul><li>因为空struct{}的实例（struct{}{}）本身不占用内存空间，所以可以用来当作占位符使用</li></ul></li><li><strong>使用场景</strong><ul><li>go语言没有set类型，可以利用map来实现，map的key为需要存储的元素，value可以使用stuct{}{}</li><li>协程之间使用channel进行通信时，如果不在乎通信的内容，仅仅只是接受一个信号，那么可以使用struct{}{}</li></ul></li></ul>
              </div>
            </details>

<h2 id="int和int32是同一个概念吗"><a href="#int和int32是同一个概念吗" class="headerlink" title="int和int32是同一个概念吗"></a>int和int32是同一个概念吗</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>int32仅仅表示32位的无符号整数</li><li>int底层基于操作系统实现，其大小取决于操作系统的位数<ul><li>int在32位系统中的int和int32是相同的，在64位系统则表示64位整数</li><li>int基于操作系统的底层实现是golang能够在不同平台运行的基础</li></ul></li></ul>
              </div>
            </details>

<h2 id="golang程序初始化执行顺序"><a href="#golang程序初始化执行顺序" class="headerlink" title="golang程序初始化执行顺序"></a>golang程序初始化执行顺序</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>import –&gt; const –&gt; var –&gt;init()–&gt;main()</li><li>单个源文件存在多个init时，从上至下依次执行</li><li>相同包下多个源文件都存在init时，根据文件名的字典序执行</li><li>import导包过程中<ul><li>有依赖关系：递归执行上述流程</li><li>无依赖关系：按照导包顺序依次执行</li></ul></li></ul>
              </div>
            </details>

<h2 id="struct能否比较"><a href="#struct能否比较" class="headerlink" title="struct能否比较"></a>struct能否比较</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>不同类型的struct不能比较</li><li>相同类型的struct分为两种情况<ul><li>若struct内所有成员均可比较，则该struct的不同实例可以比较</li><li>反之，如含有slice、map、function，则不能比较</li></ul></li></ul>
              </div>
            </details>

<h2 id="interface能否比较"><a href="#interface能否比较" class="headerlink" title="interface能否比较"></a>interface能否比较</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>可以进行比较</li><li>只在两种情况下相等：<ul><li>两个interface均等于nil</li><li>两个interface内部的类型和值都相等</li></ul></li></ul>
              </div>
            </details>

<h2 id="两个nil可能不相等吗"><a href="#两个nil可能不相等吗" class="headerlink" title="两个nil可能不相等吗"></a>两个nil可能不相等吗</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>只有在类型相同时两个nil才相等</li></ul><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p1, p2 *<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> p3 *<span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p1==p3 类型不同，编译不通过</span></span><br><span class="line">fmt.Println(p1 == <span class="literal">nil</span>, p2 == <span class="literal">nil</span>, p1 == p2) <span class="comment">// true true true</span></span><br><span class="line">fmt.Println(a == <span class="literal">nil</span>, p == <span class="literal">nil</span>, a == p) <span class="comment">// true true false</span></span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<h2 id="值类型T和指针类型-T可以互相调用方法吗"><a href="#值类型T和指针类型-T可以互相调用方法吗" class="headerlink" title="值类型T和指针类型*T可以互相调用方法吗"></a>值类型T和指针类型*T可以互相调用方法吗</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>使用值类型T调用*T的方法，只有当此T是可寻址的情况下才可以。比如常量就无法寻址，也就无法对其进行取地址操作。</li><li>反过来，*T只有在不是空指针的情况下才可以调用值类型T的方法。</li></ul><div class="tabs" id="tab-first"><ul class="nav-tabs"><li class="tab active"><a class="#first-1">T调用*T的方法</a></li><li class="tab"><a class="#first-2">*T调用T的方法</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-1"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myInt)</span></span> f() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ⬇️会报错，因为3无法寻址</span></span><br><span class="line">	<span class="comment">// myInt(3).f()</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a myInt = <span class="number">3</span></span><br><span class="line">	a.f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="first-2"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*test)</span></span> f1() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;f1 ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(test)</span></span> f2() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;f2 ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> t1 *T</span><br><span class="line">	t1.f1()</span><br><span class="line">    <span class="comment">// ⬇️ *T调用T的方法时会自动解引用，而*T解引用后是nil，nil调用方法会报错</span></span><br><span class="line">	<span class="comment">// t1.f2()</span></span><br><span class="line">	<span class="keyword">var</span> t2 T</span><br><span class="line">	t2.f1()</span><br><span class="line">	t2.f2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div></div>
              </div>
            </details>

<h2 id="值接收者和指针接收者实现接口的区别"><a href="#值接收者和指针接收者实现接口的区别" class="headerlink" title="值接收者和指针接收者实现接口的区别"></a>值接收者和指针接收者实现接口的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>使用值接收者实现接口之后，不管是值类型的变量还是指针类型的变量都可以赋值给接口变量，因为对一个不为空的对象进行解引用总是合法的</li><li>但使用指针接收者实现接口后，只能将指针类型的变量赋值给接口变量，如果使用值类型进行赋值，在接口转换过程中，该值类型可能无法被取地址，会导致无法调用指针方法，因此在编译阶段就杜绝了这种行为</li></ul>
              </div>
            </details>

<h2 id="v、-v、-v的区别"><a href="#v、-v、-v的区别" class="headerlink" title="%v、%+v、%#v的区别"></a>%v、%+v、%#v的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>%v 只输出所有的值</li><li>%+v 先输出字段类型，再输出该字段的值</li><li>%#v 先输出结构体名字值，再输出结构体（字段类型+字段的值）</li></ul><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := &amp;student&#123;<span class="string">&quot;luxiao&quot;</span>, <span class="number">123456</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%%v的方式  = %v\n&quot;</span>, s)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%%+v的方式 = %+v\n&quot;</span>, s)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%%#v的方式 = %#v\n&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// %v的方式  = &amp;&#123;luxiao 123456&#125;</span></span><br><span class="line"><span class="comment">// %+v的方式 = &amp;&#123;name:&quot;luxiao&quot; id:123456&#125;</span></span><br><span class="line"><span class="comment">// %#v的方式 = &amp;main.student&#123;name:&quot;luxiao&quot;, id:123456&#125;</span></span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<h2 id="指针的作用"><a href="#指针的作用" class="headerlink" title="指针的作用"></a>指针的作用</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>函数传参或者方法中传递接收者时，如果要对原值进行修改，一般传递指针参数</li><li>如果结构体比较大的话，使用指针可以节省空间并提高效率</li></ul>
              </div>
            </details>

<h2 id="介绍一下context"><a href="#介绍一下context" class="headerlink" title="介绍一下context"></a>介绍一下context</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>context用来管理上下文，具体有如下作用<ul><li>传递取消信号：可以用来传递取消信号，让一个正在执行的函数知道它应该提前终止</li><li>超时控制：可以设定一个超时时间，自动取消超过执行时间的操作</li><li>截止时间：与超时类似，但是是设定一个绝对时间点，而不是时间段</li><li>值传递：可以安全地在请求的上下文中传递数据，避免了使用全局变量或者参数列表不断增长</li></ul></li><li>Context是一个接口，该接口定义了四个需要实现的方法<ul><li>Deadline方法需要返回当前Context被取消的时间，也就是完成工作的截止时间（deadline）</li><li>Done方法需要返回一个Channel，这个Channel会在当前工作完成或者上下文被取消之后关闭，多次调用Done方法会返回同一个Channel</li><li>Err方法会返回当前Context结束的原因，它只会在Done返回的Channel被关闭时才会返回非空的值；</li><li>Value方法会从Context中返回键对应的值</li></ul></li><li>可以使用Background或Todo创建顶层上下文，使用WithCancel、WithDeadline、WithTimeout或WithValue创建派生上下文</li><li>当一个上下文被取消时，它派生的所有上下文也被取消</li></ul><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<h1 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h1><h2 id="数组和切片的区别"><a href="#数组和切片的区别" class="headerlink" title="数组和切片的区别"></a>数组和切片的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>长度是否可变</strong><ul><li>数组是一个长度固定的数据类型，其长度在定义时就已经确定，不能动态改变</li><li>切片是一个长度可变的数据类型，其长度在定义时可以为空，也可以指定一个初始长度（和容量），后续可以自动扩容</li></ul></li><li><strong>内存分配时机</strong><ul><li>数组在编译时期确定内存分配</li><li>切片在运行时期动态分配内存</li></ul></li><li><strong>参数传递方式</strong><ul><li>本质上数组和切片都是值传递</li><li>当数组作为函数参数时，函数操作的是数组的一个副本，不会影响原始数组</li><li>当切片作为函数参数时，函数操作的是切片中底层数组的引用，会影响原始切片，<strong>但是存在特例</strong>，当切片在函数中进行扩容时，会导致这个切片的底层指针指向新的底层数组，不再和原切片共享一个底层数组，发生扩容后函数修改切片不会对原切片造成影响</li></ul></li></ul>
              </div>
            </details>

<h2 id="slice底层原理"><a href="#slice底层原理" class="headerlink" title="slice底层原理"></a>slice底层原理</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>组成</strong><ul><li>指针、长度和容量。指针指向底层数组，长度代表slice当前的长度，容量代表底层数组的长度</li></ul></li><li><strong>append追加原则</strong><ul><li>假如slice容量够用，则追加新元素进去，返回原来的slice</li><li>若原容量不够，则slice 先扩容，扩容之后得到新的slice，将元素追加进新的slice，最后返回新的slice</li></ul></li><li><strong>扩容规则</strong><ul><li>1.18之前：当切片容量小于1024时，扩容为原来的2倍，这样可以避免频繁扩容；当切片容量大于等于1024时，扩容为原来的1.25倍，这样可以避免内存浪费；如果扩容后还不够，则直接使用需要的容量</li><li>1.18及之后：当切片容量小于256时，扩容为原来的两倍；当切片容量大于等于256时，按照公式进行扩容<code>newcap+=(newcap+3*256)/4</code>；如果扩容后还不够，则直接使用需要的容量</li><li>改版之后扩容过程相对于原来更为平缓</li></ul></li></ul>
              </div>
            </details>

<h2 id="切片的深浅拷贝"><a href="#切片的深浅拷贝" class="headerlink" title="切片的深浅拷贝"></a>切片的深浅拷贝</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>深浅拷贝都是进行复制，本质区别就是复制出来的对象与原对象的底层数组指针是否会指向同一个地址<ul><li>深拷贝会在内存中重新开辟一块内存，再让底层指针指向这片新的内存</li><li>浅拷贝会和原切片共享同一个底层数组</li></ul></li><li>具体应用<ul><li>使用**&#x3D;操作符和[ : ]下标**的方式拷贝切片是浅拷贝</li><li>使用<strong>copy()函数</strong>复制是深拷贝</li></ul></li></ul>
              </div>
            </details>

<h2 id="零切片、nil切片、空切片"><a href="#零切片、nil切片、空切片" class="headerlink" title="零切片、nil切片、空切片"></a>零切片、nil切片、空切片</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>零切片</strong><ul><li>切片元素为相应的零值的切片</li></ul></li><li><strong>nil切片</strong><ul><li>长度和容量都为0</li><li>和nil比较的结果为true</li></ul></li><li><strong>空切片</strong><ul><li>长度和容量也都为0</li><li>和nil的比较结果为false，因为所有的空切片的底层指针都指向同一个地址</li></ul></li></ul><div class="tabs" id="tab-second"><ul class="nav-tabs"><li class="tab active"><a class="#second-1">零切片</a></li><li class="tab"><a class="#second-2">nil切片</a></li><li class="tab"><a class="#second-3">空切片</a></li></ul><div class="tab-content"><div class="tab-pane active" id="second-1"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">5</span>) <span class="comment">// 0 0 0 0 0</span></span><br><span class="line">slice := <span class="built_in">make</span>([]*<span class="type">int</span>,<span class="number">5</span>) <span class="comment">// nil nil nil nil nil</span></span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="second-2"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> slice = *<span class="built_in">new</span>([]<span class="type">int</span>)</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="second-3"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div></div></div></div>
              </div>
            </details>

<h2 id="判断两个切片是否相等"><a href="#判断两个切片是否相等" class="headerlink" title="判断两个切片是否相等"></a>判断两个切片是否相等</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>可以调用reflect包下的DeepEqual()，但并不建议这么做，因为其底层使用了反射进行判断，比较影响性能</li><li>在知道切片类型的情况下，自己实现循环比较的性能更佳</li></ul>
              </div>
            </details>

<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="map常识"><a href="#map常识" class="headerlink" title="map常识"></a>map常识</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>map基于key的维度进行去重</li><li>map的遍历是无序的，若想要顺序遍历，则需要先对key排序，再按照key的顺序遍历map</li><li>对map进行读、写、删的操作的时间复杂度为O(1)</li><li>key必须为可比较类型，go语言中slice、map、func三种类型不可比较</li><li>map不是并发安全的，读map时可以并发读，但是写map时并发读写都不被允许。若要实现map的并发读写，有两种方式<ul><li>map+互斥锁&#x2F;读写锁</li><li>使用go自带的并发安全的sync.Map</li></ul></li></ul>
              </div>
            </details>

<h2 id="map为什么是无序的"><a href="#map为什么是无序的" class="headerlink" title="map为什么是无序的"></a>map为什么是无序的</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>其一，map在进行扩容的过程中可能打乱原始键值对的顺序</li><li>其二，官方在for-range遍历map时做了随机播种</li></ul>
              </div>
            </details>

<h2 id="map中删除一个key，它的内存会释放么"><a href="#map中删除一个key，它的内存会释放么" class="headerlink" title="map中删除一个key，它的内存会释放么"></a>map中删除一个key，它的内存会释放么</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>如果删除的元素是值类型，如int，float，bool，string以及数组和struct，map的内存不会自动释放</li><li>如果删除的元素是引用类型，如指针，slice，map，chan等，map的内存会自动释放，但释放的内存是子元素应用类型的内存占用</li><li>将map设置为nil后，内存被回收</li></ul>
              </div>
            </details>

<h2 id="map底层结构"><a href="#map底层结构" class="headerlink" title="map底层结构"></a>map底层结构</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>map在底层算法上通过哈希表实现</li><li>每个map都是一个指针，指向hmap结构体，hmap主要包含一个桶数组的指针（buckets），以及维护这个桶数组所需的一些字段</li><li>桶数组中每个元素都是一个bmap结构体，也就是所谓的桶，每个桶固定可以存放8个kv键值对以及一个指向下一个溢出桶的指针</li><li>每个kv键值对数据包含tophash(key的高8位哈希值)、key、val三部分</li></ul><div class="tabs" id="tab-third"><ul class="nav-tabs"><li class="tab active"><a class="#third-1">数据结构</a></li><li class="tab"><a class="#third-2">图示</a></li></ul><div class="tab-content"><div class="tab-pane active" id="third-1"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count     <span class="type">int</span>    <span class="comment">// map中kv键值对总数</span></span><br><span class="line">	flags     <span class="type">uint8</span>  <span class="comment">// 状态标志，标识出map是否被并发读写</span></span><br><span class="line">	B         <span class="type">uint8</span>  <span class="comment">// 桶数组长度的指数，桶数组长度为2^B</span></span><br><span class="line">	noverflow <span class="type">uint16</span> <span class="comment">// 溢出桶的数量</span></span><br><span class="line">	hash0     <span class="type">uint32</span> <span class="comment">// 随机因子，生成key的hash值时会用到</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// 桶数组的指针</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// 扩容过程中旧的桶数组</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span>        <span class="comment">// 扩容进度标识，小于此地址的buckets代表已搬迁完成。</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// 预申请的溢出桶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="third-2"><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/map-structure.png"
                      alt="map structure"
                ></p></div></div></div>
              </div>
            </details>

<h2 id="map读写过程"><a href="#map读写过程" class="headerlink" title="map读写过程"></a>map读写过程</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p><strong>读流程</strong></p><ol><li>根据key取hash值</li><li>根据hash值以及B对桶数组长度取模，确定所在的桶</li><li>沿着桶链表依次遍历各个桶内的kv键值对</li><li>命中相同的key则返回value，若key不存在则返回零值</li></ol></li><li><p><strong>写流程</strong></p><ul><li>基本一致，只是如果发现map处在扩容过程中则会帮助推进渐进式扩容</li></ul></li></ul><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/map-process.png"
                      alt="map process"
                ></p>
              </div>
            </details>

<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>产生原因</strong><ul><li>由于输入域（key）无穷大，输出域（hash 值）有限，因此必然存在不同 key 映射到相同 hash 值的情况，称之为 hash 冲突</li><li>再者，hash 值会对桶数组长度取模，因此不同 hash 值可能被打到同一个桶中</li></ul></li><li><strong>常见解决办法</strong><ul><li><strong>拉链法</strong><ul><li>将命中同一个位置的元素通过链表的形式进行链接</li><li>无需预先为元素分配内存，便于动态扩展</li></ul></li><li><strong>开放寻址法</strong><ul><li>在插入新条目时，会基于一定的探测策略持续寻找，直到找到一个可用于存放数据的空位为止</li><li>无需额外的指针用于链接元素；内存地址完全连续，可以基于局部性原理，充分利用 CPU 高速缓存</li></ul></li></ul></li><li><strong>go语言的处理方法</strong>（结合拉链法和开放寻址法两种思路）<ul><li>当 key 命中一个桶时，首先根据开放寻址法，在桶的 8 个位置中寻找空位进行插入</li><li>倘若桶的 8 个位置都已被占满，则基于桶的溢出桶指针，找到下一个桶，重复第上一步</li><li>倘若遍历到链表尾部，仍未找到空位，则基于拉链法，在桶链表尾部续接新桶，并插入kv对</li></ul></li></ul>
              </div>
            </details>

<h2 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>渐进式扩容</strong><ul><li>每次写操作都会帮助推进扩容的过程，避免因为一次性的全量数据迁移引发性能抖动</li></ul></li><li><strong>扩容类型</strong><ul><li><strong>增量扩容</strong><ul><li>扩容后，桶数组的长度增长为原长度的 2 倍</li><li>目的是降低每个桶中 key-value 对的数量，优化 map 操作的时间复杂度</li></ul></li><li><strong>等量扩容</strong><ul><li>扩容后，桶数组的长度和之前保持一致，但是溢出桶的数量会下降</li><li>目的是提高桶主体结构的数据填充率，减少溢出桶数量，避免发生内存泄漏</li></ul></li></ul></li><li><strong>扩容时机</strong><ul><li><strong>装载因子超出阈值6.5</strong><ul><li>map 中 key-value 对的数量超过 8 个，且大于桶数组长度的 6.5 倍，则进入增量扩容</li></ul></li><li><strong>溢出桶数量过多</strong><ul><li>若溢出桶的数量大于 2^B 个（即桶数组的长度；B 大于 15 时取15），则进入等量扩容</li></ul></li></ul></li></ul><div class="tabs" id="tab-fourth"><ul class="nav-tabs"><li class="tab active"><a class="#fourth-1">增量扩容</a></li><li class="tab"><a class="#fourth-2">等量扩容</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fourth-1"><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/map-double-incr.png"
                      alt="double incr"
                ></p></div><div class="tab-pane" id="fourth-2"><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/map-equal-incr.png"
                      alt="equal incr"
                ></p></div></div></div>
              </div>
            </details>

<h2 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ol><li>计算新的存储桶数量：当map 的元素数量达到负载因子 (load factor)的上限时，会触发扩容。新的存储桶数量通常会是当前存储桶数量的两倍。</li><li>分配新的存储桶：创建新的存储桶和散列数组，大小为新的存储桶数量</li><li>重新散列元素：遍历当前 map 的每个存储桶，将其中的元素重新散列到新的存储桶中，这个过程是渐进式的</li><li>切换到新的存储桶：将 map 的内部数据结构指向新的存储桶和散列数组，这个过程是原子的，以确保在切换期间不会影响并发访问。</li><li>释放旧的存储桶：释放的存储桶和散列数组的内存空间，避免内存泄漏</li></ol>
              </div>
            </details>

<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><h2 id="无缓冲的channel和有缓冲的channel的区别"><a href="#无缓冲的channel和有缓冲的channel的区别" class="headerlink" title="无缓冲的channel和有缓冲的channel的区别"></a>无缓冲的channel和有缓冲的channel的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>无缓冲channel是同步的，有缓冲channel是异步的</strong></li><li>对于无缓冲的channel<ul><li>发送方向channel发送数据，但没有接收方接受数据时，发送方阻塞</li><li>接收方从channel接收数据，但没有发送方发送数据时，接收方阻塞</li></ul></li><li>对于有缓冲的channel<ul><li>发送方只有在缓冲区满时阻塞</li><li>接收方只有在缓冲区空时阻塞</li></ul></li><li>无缓冲的channel其实可以看作缓冲区大小为0的channel，从这个角度看，无缓冲channel兼具了缓冲区满和缓冲区空的特点</li></ul>
              </div>
            </details>

<h2 id="channel的底层原理"><a href="#channel的底层原理" class="headerlink" title="channel的底层原理"></a>channel的底层原理</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>每个channel都对应一个hchan结构体，hchan主要包括一个循环数组，以及一些维护这个循环数组的字段</li><li>比较重要的几个字段<ul><li>buf 指向底层循环数组，只有缓冲型的 channel 才有。</li><li>sendx，recvx 均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。</li><li>sendq，recvq 分别表示被阻塞的 goroutine的等待队列，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。</li><li>lock 用来保证每个读 channel 或写 channel 的操作都是原子的。</li></ul></li></ul><div class="tabs" id="tab-fifth"><ul class="nav-tabs"><li class="tab active"><a class="#fifth-1">channel数据结构</a></li><li class="tab"><a class="#fifth-2">图示</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fifth-1"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// chan 里元素数量</span></span><br><span class="line">    qcount <span class="type">uint</span></span><br><span class="line">    <span class="comment">// chan 底层循环数组的长度</span></span><br><span class="line">    dataqsiz <span class="type">uint</span></span><br><span class="line">    <span class="comment">// 指向底层循环数组的指针</span></span><br><span class="line">    <span class="comment">// 只针对有缓冲的 channel</span></span><br><span class="line">    buf unsafe.Pointer</span><br><span class="line">    <span class="comment">// chan 中元素大小</span></span><br><span class="line">    elemsize <span class="type">uint16</span></span><br><span class="line">    <span class="comment">// chan 是否被关闭的标志</span></span><br><span class="line">    closed <span class="type">uint32</span></span><br><span class="line">    <span class="comment">// chan 中元素类型</span></span><br><span class="line">    elemtype *_type  <span class="comment">// element type</span></span><br><span class="line">    <span class="comment">// 已发送元素在循环数组中的索引</span></span><br><span class="line">    sendx <span class="type">uint</span>  <span class="comment">// send index</span></span><br><span class="line">    <span class="comment">// 已接收元素在循环数组中的索引</span></span><br><span class="line">    recvx <span class="type">uint</span>  <span class="comment">// receive index</span></span><br><span class="line">    <span class="comment">// 等待接收的 goroutine 队列</span></span><br><span class="line">    recvq waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">    <span class="comment">// 等待发送的 goroutine 队列</span></span><br><span class="line">    sendq waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">    <span class="comment">// 保护 hchan 中所有字段</span></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="fifth-2"><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/channel-structure.png"
                      alt="channel structure"
                ></p></div></div></div>
              </div>
            </details>

<h2 id="channel发送和接收数据的过程"><a href="#channel发送和接收数据的过程" class="headerlink" title="channel发送和接收数据的过程"></a>channel发送和接收数据的过程</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>goroutine向channel发送数据<ul><li>goroutine首先获取channel的锁</li><li>如果channel缓冲区未满，则直接将数写入缓冲区，并更新sendx</li><li>如果缓冲区已满，则将当前goroutine挂到sendq等待队列中，并释放锁，等到有goroutine接受数据才会被唤醒</li></ul></li><li>channel从goroutine接收数据<ul><li>goroutine首先获取channel的锁</li><li>如果channel缓冲区非空，则直接从缓冲区读取数据，并更新recvx</li><li>如果缓冲区为空，则将当前goroutine挂到recvq等待队列中，并释放锁，等到有goroutine写入数据才会被唤醒</li></ul></li></ul>
              </div>
            </details>

<h2 id="操作channel的情况"><a href="#操作channel的情况" class="headerlink" title="操作channel的情况"></a>操作channel的情况</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <table><thead><tr><th><strong>操作</strong></th><th align="center"><strong>nil channel</strong></th><th align="center"><strong>closed channel</strong></th><th align="center"><strong>not nil, not closed channel</strong></th></tr></thead><tbody><tr><td><strong>close</strong></td><td align="center">panic</td><td align="center">panic</td><td align="center">正常关闭</td></tr><tr><td><strong>读</strong></td><td align="center">阻塞</td><td align="center">读到对应类型的零值</td><td align="center">阻塞或正常读取数据。缓冲型 channel 为空或非缓冲型 channel 没有等待发送者时会阻塞</td></tr><tr><td><strong>写</strong></td><td align="center">阻塞</td><td align="center">panic</td><td align="center">阻塞或正常写入数据，非缓冲型 channel 没有等待接收者或缓冲型 channel buf 满时会被阻塞</td></tr></tbody></table>
              </div>
            </details>

<h1 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h1><h2 id="mutex有几种模式"><a href="#mutex有几种模式" class="headerlink" title="mutex有几种模式"></a>mutex有几种模式</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>正常模式</strong><ul><li>在正常模式下，一个尝试加锁的goroutine会先自旋几次，尝试通过原子操作获得锁，若几次自旋之后仍不能获得锁，则通过信号量排队等待。但是当锁被释放，第一个等待者被唤醒后并不会直接拥有锁，而是需要和后来者竞争，也就是那些处于自旋阶段，尚未排队等待的goroutine。这种情况下后来者更有优势，一方面，它们正在CPU上运行，自然比刚被唤醒的goroutine更有优势，另一方面处于自旋状态的goroutine可以有很多，而被唤醒的goroutine每次只有一个，所以被唤醒的goroutine有很大概率拿不到锁。这种情况下它会被重新插入到队列的头部，而不是尾部。而当一个goroutine本次加锁等待时间超过了1ms后，它会把当前Mutex从正常模式切换至“饥饿模式”。</li></ul></li><li><strong>饥饿模式</strong><ul><li>在饥饿模式下，Mutex的所有权从执行Unlock的goroutine，直接传递给等待队列头部的goroutine，后来者不会自旋，也不会尝试获得锁，即使Mutex处于Unlocked的状态。它们会直接到队列的尾部排队等待。当一个等待者获得锁之后，它会在以下两种情况时，将Mutex由饥饿模式切换回正常模式。第一种情况是它的等待时间小于1ms，也就是它刚来不久；第二种情况是它是最后一个等待者，等待队列已经空了，后面自然就没有饥饿的goroutine了。</li></ul></li></ul>
              </div>
            </details>

<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>RWMutex</strong><ul><li>并发读不互斥，并发写和并发读写都互斥</li></ul></li><li><strong>内部结构</strong><ul><li>w: 对写任务进行并发控制，获取写锁时首先需要获取该锁，如果它已被某个写任务占据，则后来获取的写任务会阻塞在该锁上</li><li>writerSem：写操作等待的信号量，当写任务可以执行时释放该信号量</li><li>readerSem：读操作等待的信号量，当读任务可以执行时释放该信号量</li><li>readerCount：记录读任务的数量，当其值为负时，表示有写任务在等待或正在处理</li><li>readerWait：用于实现<strong>写优先的关键逻辑</strong>，写任务需要等待多少个读任务结束，才可以执行</li></ul></li></ul><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w Mutex <span class="comment">// held if there are pending writers</span></span><br><span class="line"></span><br><span class="line">    writerSem <span class="type">uint32</span> <span class="comment">// semaphore for writers to wait for completing readers</span></span><br><span class="line">    readerSem <span class="type">uint32</span> <span class="comment">// semaphore for readers to wait for completing writers</span></span><br><span class="line">    readerCount <span class="type">int32</span> <span class="comment">// number of pending readers</span></span><br><span class="line">    readerWait <span class="type">int32</span> <span class="comment">// number of departing readers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><strong>获取和释放读写锁的过程</strong></li></ul><div class="tabs" id="tab-rwlock"><ul class="nav-tabs"><li class="tab active"><a class="#rwlock-1">读锁</a></li><li class="tab"><a class="#rwlock-2">写锁</a></li><li class="tab"><a class="#rwlock-3">场景图示</a></li></ul><div class="tab-content"><div class="tab-pane active" id="rwlock-1"><ul><li>获取读锁<ol><li>获取读锁时，先将读计数器 readerCount增1，表示增加一个读任务</li><li>当readerCount值为负时，表示前面存在等待处理写任务或有写任务正在处理，此时阻塞新接收到的读任务，等待信号量通知</li></ol></li></ul><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// readerCount计数器++</span></span><br><span class="line">    <span class="comment">// 小于0，表示存在等待处理/正在处理的写操作</span></span><br><span class="line">    <span class="comment">// 新加入的读操作阻塞，等待readerSem信号量通知</span></span><br><span class="line">    <span class="comment">// &gt; 0: 表示只有读锁，读读不冲突，上锁成功，函数退出    </span></span><br><span class="line">    <span class="comment">//  ======== 此处就是写优先的逻辑逻辑===========</span></span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>释放读锁<ol><li>释放读锁时，先将读计数器减一，表示完成一个读任务</li><li>如果readerCount为负，则存在需要优先处理的写任务</li><li>因为此时存在写任务，readerWait已被写任务赋值，将该值减一，表示写任务执行前要处理的读任务完成一个</li><li>如果readerWait为0，则表示写任务执行之前的所有读任务都已完成，释放写信号量，执行等待处理的写任务</li></ol></li></ul><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读计数器--</span></span><br><span class="line">    <span class="comment">// &lt; 0，表示存在等待处理的写操作</span></span><br><span class="line">    <span class="comment">// &gt; 0， 表示还有剩余的读锁，读读之间不需要阻塞</span></span><br><span class="line">    <span class="comment">// ==0，表示没有任何锁</span></span><br><span class="line">	<span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Outlined slow-path to allow the fast-path to be inlined</span></span><br><span class="line">		rw.rUnlockSlow(r)</span><br><span class="line">	&#125;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="comment">// 临界区检测 readerCount  [-rwmutexMaxReaders, -1] &amp;&amp; (0, rwmutexMaxReaders)</span></span><br><span class="line">	<span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		throw(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取写锁之前，需要处理的读锁数量</span></span><br><span class="line">    <span class="comment">// readerWait ==0:表示写锁之前的读锁都处理完毕，后续将锁分配给写事务，</span></span><br><span class="line">    <span class="comment">// 释放信号量，通知等待的写锁</span></span><br><span class="line">    <span class="comment">// readerWait &gt; 0: 表示还有读锁在处理，退出调用.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">		runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="rwlock-2"><ul><li>获取写锁<ol><li>获取写锁时，先抢占互斥锁，因为当存在多个写任务时，同一时间仅会处理一个</li><li>反转readerCount的值为负，同时计算收到写任务时的读任务数量</li><li>当读任务数量&gt;0时，表示存在正在处理的读任务，将该值累加给readerWait，表示执行接收到的写任务时需要执行多少任务</li><li>当readWait &gt; 0，表示有任务要执行，因为通过信号量将写任务阻塞</li></ol></li></ul><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">    ....</span><br><span class="line">    先上锁，排除其它写锁竞争</span><br><span class="line">	rw.w.Lock()</span><br><span class="line">	<span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">	<span class="comment">// Wait for active readers.</span></span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>释放写锁<ol><li>释放写锁时，先将readerCount反转为正值表示写任务执行完成，并计算读任务的数量；在释放写锁期间如果有新到的并发读任务，因为readerCount&gt;&#x3D;0，可以立即获取读锁执行</li><li>释放r次读信号量，将在写任务期间被阻塞的读任务唤醒执行</li><li>释放Mutex互斥锁</li></ol></li></ul><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">    ....</span><br><span class="line">	<span class="comment">// Announce to readers there is no active writer.</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">	<span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		throw(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Unblock blocked readers, if any.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Allow other writers to proceed.</span></span><br><span class="line">	rw.w.Unlock()</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="rwlock-3"><ul><li><strong>场景</strong><ul><li>t1时刻初始有5个读锁【R1、R2、R3、R4、R5】</li><li>在t1-&gt;t2读锁执行期间，收到一个写锁调用【W1】和3个读锁调用【R6、R7、R8】</li><li>在t2时间段后，交互收到2个写调用【W2、W3】、2个读调用【R9、R10】</li></ul></li><li><strong>图示</strong></li></ul><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/rwlock.png"
                      alt="rwlock"
                ></p></div></div></div>
              </div>
            </details>

<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>CAS的全称为Compare And Swap，直译就是比较交换，是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值</li><li>假设包含3个参数内存位置(V)、预期原值(A)和新值(B)。V表示要更新变量的值，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程在做更新，则当前线程什么都不做，最后CAS返回当前V的真实值。CAS操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对于当前线程的干扰。</li></ul>
              </div>
            </details>

<h1 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h1><h2 id="什么是GMP"><a href="#什么是GMP" class="headerlink" title="什么是GMP"></a>什么是GMP</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>Goroutine (G)</strong><ul><li>Goroutine是Go语言中的轻量级线程，能够与其他goroutine并发执行。</li><li>与传统的线程相比，goroutine的创建和销毁成本非常低。</li><li>Goroutine由Go的运行时系统调度，不依赖于操作系统的线程调度。</li></ul></li><li><strong>Machine (M)</strong><ul><li>Machine代表操作系统的线程。</li><li>M负责执行Goroutine。</li></ul></li><li><strong>Processor (P)</strong><ul><li>Processor是一个逻辑处理器，负责Goroutine的调度。</li><li>P维护一个本地队列，其中保存了准备运行的Goroutine。</li><li>每个P都绑定到一个M上，如果绑定后的M获取不到可执行的G，那么该M就会自旋，而其他绑定不到P的M会休眠</li></ul></li></ul><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/gmp.jpg"
                      alt="gmp"
                ></p>
              </div>
            </details>

<h2 id="GMP的工作原理"><a href="#GMP的工作原理" class="headerlink" title="GMP的工作原理"></a>GMP的工作原理</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>首先通过go func()创建一个Goroutine</li><li>这个创建的G会优先放入当前P的本地队列中，如果本地队列满了，则会把本地队列中一半的G和这个创建的G放入全局队列中</li><li>然后M从P的本地队列中获取一个G来执行，如果本地队列已经没有可运行的G，则会从全局队列中获取，如果全局队列中获取不到，则采取work stealing机制，从其他P的本地队列中偷取一半的G，如果偷取不到，那么该M会进入自旋状态，等待新的goroutine执行</li><li>M在执行goroutine时会遇到3种情况<ul><li>正常情况下，当前goroutine执行完成后，M上运行的goroutine会切换成G0，G0负责调度时的协程切换，G0会从P的本地队列中再获取G，然后M从G0切换到这个G，并开始运行它</li><li>如果当前goroutine运行时间超过10ms，因为是抢占式调度，M会暂停执行该goroutine，将其放回本地队列尾部，转而执行其他的goroutine</li><li>如果M执行G时发生了阻塞，那么就会采用hand off机制，M会释放当前绑定的P，然后创建一个新的M服务这个P（如果有空闲的M就直接复用），当原来的M退出阻塞状态之后，它会尝试获取之前释放的P，如果无法获取，则获取空闲的P，如果依然没有，那么挂载在这个M上的G会被标记为可运行状态，放回到全局队列中，这个M进入休眠状态</li></ul></li></ul>
              </div>
            </details>

<h2 id="P和-M的数量关系"><a href="#P和-M的数量关系" class="headerlink" title="P和 M的数量关系"></a>P和 M的数量关系</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>P 的数量：由 runtime 的 GOMAXPROCS 决定。</li><li>M 的数量：<ul><li>go 程序启动时，会设置 M 的最大数量，默认 10000，但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li><li>runtime&#x2F;debug 中的 SetMaxThreads 函数，可以设置 M 的最大数量。</li></ul></li><li>M的数量&gt;&#x3D;P的数量，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来</li></ul>
              </div>
            </details>

<h2 id="P和-M何时会被创建"><a href="#P和-M何时会被创建" class="headerlink" title="P和 M何时会被创建"></a>P和 M何时会被创建</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>P 何时创建<ul><li>在确定了 P 的最大数量 n 后，runtime会根据这个数量创建 n 个 P</li></ul></li><li>M 何时创建<ul><li>没有足够的 M 来关联 P 并运行其中的可运行的 G</li><li>比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。</li></ul></li></ul>
              </div>
            </details>

<h2 id="M0和G0"><a href="#M0和G0" class="headerlink" title="M0和G0"></a>M0和G0</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了</li><li>G0 是每次启动一个 M 都会创建的一个 goroutine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0</li></ul>
              </div>
            </details>

<h2 id="没有P会怎样"><a href="#没有P会怎样" class="headerlink" title="没有P会怎样"></a>没有P会怎样</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>Go语言早期的调度模型（GM模型）就是没有P的，这样的调度模型会存在一些性能问题</li><li>没有P也就没有本地队列，M想要执行和放回G都需要通过全局队列来完成，而多线程访问同一资源需要通过加锁来保证同步</li><li>创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的锁竞争</li><li>M 转移 G 会造成延迟和额外的系统负载。比如当 G1 中创建新协程的时候，M1创建了 G2，为了继续执行 G1，需要把 G2交给M2执行，也造成了很差的局部性，因为 G2 和 G1 是相关的，最好放在 M1 上执行，而不是其他的M</li></ul>
              </div>
            </details>

<h2 id="work-stealing机制为什么不需要加锁"><a href="#work-stealing机制为什么不需要加锁" class="headerlink" title="work stealing机制为什么不需要加锁"></a>work stealing机制为什么不需要加锁</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <p>P 从本地队列取 G 的这个操作，是一个 CAS 操作，它具有原子性，是由硬件直接支持的，不需要并发的竞争关系</p>
              </div>
            </details>

<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="CSP并发模型"><a href="#CSP并发模型" class="headerlink" title="CSP并发模型"></a>CSP并发模型</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>CSP（Communicating Sequential Processes，通信顺序进程），其设计理念是<strong>通过通信来共享内存，而不是通过共享内存来通信</strong></li><li>go语言的并发模型基于CSP，通过goroutine和channel来实现</li></ul>
              </div>
            </details>

<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <p>原子操作是一组不可分割的操作，用于在并发环境中安全地修改共享资源。Go语言的sync&#x2F;atomic包提供了一组原子操作函数，用于对基本数据类型（如整数）进行安全的读写，防止竞态条件。</p>
              </div>
            </details>

<h2 id="什么时候会发生阻塞"><a href="#什么时候会发生阻塞" class="headerlink" title="什么时候会发生阻塞"></a>什么时候会发生阻塞</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>系统调用<ul><li>当Goroutine执行一个阻塞的系统调用（如文件I&#x2F;O、网络I&#x2F;O等）时，它会被阻塞，直到系统调用完成。</li></ul></li><li>通道操作<ul><li>Goroutine在执行通道（channel）操作时，如发送数据到一个已满的通道或从一个空的通道接收数据，可能会发生阻塞。阻塞会持续到通道中有足够的空间或数据可用。</li></ul></li></ul>
              </div>
            </details>

<h2 id="如何处理阻塞"><a href="#如何处理阻塞" class="headerlink" title="如何处理阻塞"></a>如何处理阻塞</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>在创建通道时指定缓冲区大小，即创建⼀个缓冲通道<ul><li>当缓冲区未满时，发送数据不会阻塞</li><li>当缓冲区未空时，接收数据不会阻塞</li></ul></li><li>select 语句用于处理多个通道操作，使用default分支，可以在所有通道都阻塞的情况下执行非阻塞的操作</li><li>超时控制<ul><li>context.WithTimeOut()</li><li>time.After()</li></ul></li></ul>
              </div>
            </details>

<h2 id="如何控制goroutine的生命周期"><a href="#如何控制goroutine的生命周期" class="headerlink" title="如何控制goroutine的生命周期"></a>如何控制goroutine的生命周期</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>启动</strong><ul><li>使用go关键字创建一个新的goroutine</li></ul></li><li><strong>退出</strong><ul><li>等待退出：使用sync.WaitGroup来实现等待进程自行结束</li><li>阻塞退出：通过channel发送一个信号使阻塞状态的goroutine退出</li><li>手动退出：使用context.WithCancel()手动结束goroutine</li><li>超时退出：使用context.WithTimeOut()可以实现超时强制退出</li></ul></li></ul>
              </div>
            </details>

<h1 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>含义</strong><ul><li>指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光</li></ul></li><li><strong>场景</strong><ul><li>字符串&#x2F;切片截取导致内存泄漏</li><li>goroutine被长期挂住，导致该协程中的内存也无法被释放，就会造成永久性的内存泄漏。比如协程结束时协程中的channel没有关闭，导致一直阻塞，再比如协程中有死循环等等</li></ul></li><li><strong>排查方式</strong><ul><li>pprof是Go的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是CPU使用情况、内存使用情况、goroutine运行情况等</li></ul></li></ul><div class="tabs" id="tab-sixth"><ul class="nav-tabs"><li class="tab active"><a class="#sixth-1">字符串截取</a></li><li class="tab"><a class="#sixth-2">切片截取</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sixth-1"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 以下代码，会有10字节的内存泄漏，我们知道，str0和str1底层共享内存</span></span><br><span class="line">    <span class="comment">// 只要str1一直活跃，str0 就不会被回收，10字节的内存被使用</span></span><br><span class="line">    <span class="comment">// 剩下的10字节内存就造成了临时性的内存泄漏，直到str1不再活跃</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果str0足够大，str1截取足够小，或者在高并发场景中频繁使用</span></span><br><span class="line">    <span class="comment">// 那么可想而知，会造成临时性内存泄漏，对性能产生极大影响</span></span><br><span class="line">    <span class="keyword">var</span> str0 = <span class="string">&quot;12345678901234567890&quot;</span></span><br><span class="line">    str1 := str0[:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方案 1</span></span><br><span class="line">    <span class="comment">// 将需要截取的部分先转换成[]byte，再转换成string</span></span><br><span class="line">    <span class="comment">// 但是这种方式会产生两个10字节的临时变量</span></span><br><span class="line">    <span class="comment">// string转换[]byte时产生一个10字节临时变量，[]byte转换string时产生一个10字节的临时变量</span></span><br><span class="line">    str1 := <span class="type">string</span>([]<span class="type">byte</span>(str0[:<span class="number">10</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方案 2</span></span><br><span class="line">    <span class="comment">// 仍然有一个字节的浪费</span></span><br><span class="line">    str1 := (<span class="string">&quot; &quot;</span> + str0[:<span class="number">10</span>])[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方案 3</span></span><br><span class="line">    str1 := strings.Repeat(str0[:<span class="number">10</span>], <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="sixth-2"><div class="code-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这种情况与字符串截取引起的内存泄漏情况类似，s1活跃情况下，造成s0中部分内存泄漏</span></span><br><span class="line">	<span class="keyword">var</span> s0 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	s1 := s0[:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方案 append</span></span><br><span class="line">    s1 := <span class="built_in">append</span>(s0[:<span class="number">0</span>], s0[:<span class="number">5</span>]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div></div>
              </div>
            </details>

<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>是什么</strong><ul><li>通过指针的动态范围来决定一个变量分配在栈上还是堆上</li></ul></li><li><strong>为什么</strong><ul><li>总的来说就是让变量分配到合理的位置</li><li>栈区可以自动清理内存，效率高，但空间有限</li><li>堆区空间大，但不像栈可以自动清理，需要进行垃圾回收，导致运行效率低下</li><li>逃逸分析，把一次性的变量分配到栈区，把后续可能在外部引用的对象分配到堆区</li></ul></li><li><strong>内存逃逸</strong><ul><li>如果变量在函数外部没有被引用，则一般不发生内存逃逸，优先分配到栈区，如果栈区存不下会分配到堆区</li><li>如果变量在函数外部被引用（闭包也算作此种情况），则发生内存逃逸，一定分配到堆区</li><li>此外，如果不确定是否被外部引用，如fmt.Println(x)，由于函数参数为接口类型，不确定x是否为引用类型，也视为x发生逃逸</li></ul></li><li><strong>如何避免</strong><ul><li>尽量减少不必要的指针使用</li></ul></li></ul>
              </div>
            </details>

<h2 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>标记清除法（Go 1.3） </li><li>三色标记法（Go 1.5）</li><li>三色标记法+混合写屏障（Go 1.8）</li></ul><div class="tabs" id="tab-sixth"><ul class="nav-tabs"><li class="tab active"><a class="#sixth-1">标记清除法</a></li><li class="tab"><a class="#sixth-2">三色标记法</a></li><li class="tab"><a class="#sixth-3">三色标记法+混合写屏障</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sixth-1"><ul><li><strong>过程</strong><ul><li>进行 STW（stop the world 即暂停程序业务逻辑），然后从 main 函数开始找到不可达的对象和可达的对象</li><li>开始标记，程序找出可达对象并做标记</li><li>标记结束清除未标记的对象</li><li>结束 STW 停止暂停，让程序继续运行，循环该过程直到 main 生命周期结束</li></ul></li><li><strong>缺点</strong><ul><li>STW会让程序暂停，程序会出现卡顿</li><li>进行标记需要扫描整个堆栈信息，效率低下</li></ul></li></ul></div><div class="tab-pane" id="sixth-2"><ul><li><strong>含义</strong><ul><li>三色标记算法将程序中的对象分成白色、黑色和灰色三类</li><li>白色对象表示暂无对象引用的潜在垃圾，灰色表示待处理的对象，黑色表示活跃的对象</li></ul></li><li><strong>过程</strong><ul><li>将所有对象标记为白色</li><li>从程序根节点集合出发，将第一次遍历到的节点标记为灰色放入集合列表中</li><li>遍历灰色集合，将灰色节点遍历到的白色节点标记为灰色，并把灰色节点标记为黑色</li><li>循环这个过程，直到灰色节点集合为空</li><li>回收所有的白色节点</li></ul></li><li><strong>缺陷</strong><ul><li>因为三色标记法是动态进行的，回收过程中若<strong>同时满足下面两个条件</strong>，则会出现<strong>丢失对象</strong>的问题<ul><li>一个白色对象被黑色对象引用</li><li>同时灰色对象到该白色对象的可达关系被破环</li></ul></li></ul></li><li><strong>应对办法</strong><ul><li>插入写屏障：<ul><li>对象被引用时触发的机制，当白色对象被黑色对象引用时，白色对象被标记为灰色</li><li>实现了强三色不变式，即不允许黑色对象引用白色对象（破坏第一个条件）</li><li>缺点是栈区没有屏障机制，最后会对栈执行STW，进行二次扫描</li></ul></li><li>删除写屏障：<ul><li>对象被删除时触发的机制，灰色对象对白色对象的引用被删除时，白色对象会被标记为灰色</li><li>实现了弱三色不变式，即黑色对象可以引用白色，但是该白色对象要处在灰色对象可达的链路当中（破坏第二个条件）</li><li>缺点是回收精度比较低，有些垃圾对象会到下一轮检测才被回收；同时也会进行STW二次扫描进行快照对比</li></ul></li></ul></li></ul></div><div class="tab-pane" id="sixth-3"><ul><li><strong>思想</strong><ul><li>结合了插入写屏障和删除写屏障的优点，通过变形的弱三色不变式，解决了STW所带来的性能瓶颈</li></ul></li><li><strong>过程</strong><ul><li>GC 开始时将栈上可达对象全部标记为黑色（不需要二次扫描，无需 STW）</li><li>GC 期间，任何栈上创建的新对象均为黑色</li><li>被删除引用的对象标记为灰色</li><li>被添加引用的对象标记为灰色</li></ul></li></ul></div></div></div>
              </div>
            </details>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 面试题</title>
    <url>/Interview/mysql-interview/</url>
    <content><![CDATA[<h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-first"><ul class="nav-tabs"><li class="tab active"><a class="#first-1">数值类型</a></li><li class="tab"><a class="#first-2">日期时间类型</a></li><li class="tab"><a class="#first-3">字符串类型</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-1"><ul><li><strong>整数类型</strong>：<ul><li><code>TINYINT</code>：1 字节</li><li><code>SMALLINT</code>：2 字节</li><li><code>MEDIUMINT</code>：3 字节</li><li><code>INT</code> 或 <code>INTEGER</code>：4 字节</li><li><code>BIGINT</code>：8 字节</li></ul></li><li><strong>浮点数类型</strong>：<ul><li><code>FLOAT</code>：4 字节</li><li><code>DOUBLE</code>：8 字节</li></ul></li><li><strong>定点数类型</strong>：<ul><li><code>DECIMAL(M, D)</code>：精确小数，M 为总位数，D 为小数位数。</li></ul></li></ul></div><div class="tab-pane" id="first-2"><ul><li><code>DATE</code>：日期，格式为 <code>YYYY-MM-DD</code>。</li><li><code>TIME</code>：时间，格式为 <code>HH:MM:SS</code>。</li><li><code>DATETIME</code>：日期和时间，格式为 <code>YYYY-MM-DD HH:MM:SS</code>。</li><li><code>TIMESTAMP</code>：时间戳，范围从 <code>1970-01-01 00:00:01</code> UTC 到 <code>2038-01-19 03:14:07</code> UTC。</li><li><code>YEAR</code>：年份，格式为 <code>YYYY</code>。</li></ul></div><div class="tab-pane" id="first-3"><ul><li><strong>常用</strong>：<ul><li><code>CHAR(M)</code>：固定长度字符串，M 为字符数，最多 255 个字符。</li><li><code>VARCHAR(M)</code>：可变长度字符串，M 为最大字符数，最多 65535 个字符。</li></ul></li><li><strong>文本类型</strong>：<ul><li><code>TINYTEXT</code>：最大长度 255 个字符。</li><li><code>TEXT</code>：最大长度 65535 个字符。</li><li><code>MEDIUMTEXT</code>：最大长度 16777215 个字符。</li><li><code>LONGTEXT</code>：最大长度 4294967295 个字符。</li></ul></li><li><strong>二进制大对象（BLOB）</strong>：<ul><li><code>TINYBLOB</code>：最大长度 255 字节。</li><li><code>BLOB</code>：最大长度 65535 字节。</li><li><code>MEDIUMBLOB</code>：最大长度 16777215 字节。</li><li><code>LONGBLOB</code>：最大长度 4294967295 字节。</li></ul></li></ul></div></div></div>
              </div>
            </details>

<h2 id="CHAR和VARCHAR的区别"><a href="#CHAR和VARCHAR的区别" class="headerlink" title="CHAR和VARCHAR的区别"></a>CHAR和VARCHAR的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>主要区别</strong><ul><li>CHAR 是定长的</li><li>VARCHAR 是变长的</li><li>效率上CHAR更高</li></ul></li><li><strong>存储和检索方式</strong><ul><li>CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格</li><li>VARCHAR 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理</li></ul></li><li><strong>使用场景</strong><ul><li>CHAR 更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码</li><li>VARCHAR 适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</li></ul></li></ul>
              </div>
            </details>

<h2 id="DATETIME-和-TIMESTAMP-的区别是什么"><a href="#DATETIME-和-TIMESTAMP-的区别是什么" class="headerlink" title="DATETIME 和 TIMESTAMP 的区别是什么"></a>DATETIME 和 TIMESTAMP 的区别是什么</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>格式区别</strong><ul><li>TIMESTAMP 和时区有关</li><li>DATETIME 类型没有时区信息</li></ul></li><li><strong>存储大小</strong><ul><li>TIMESTAMP 使用 4 个字节的存储空间</li><li>DATETIME 使用 8 个字节的存储空间</li></ul></li><li><strong>表示范围</strong><ul><li>TIMESTAMP：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li><li>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li></ul></li></ul>
              </div>
            </details>

<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>第一范式（1NF）</strong><ul><li>字段（或属性）是不可分割的最小单元，即不会有重复的列，体现原子性</li></ul></li><li><strong>第二范式（2NF）</strong><ul><li>满足 1NF 前提下，存在一个候选码，非主属性全部依赖该候选码，即存在主键，体现唯一性，专业术语则是消除部分函数依赖</li><li>假如学生表主键是（学生id，课程id），很明显可以通过主键推出学生姓名，但是实际上只需要学生id一个属性就可以推出学生姓名，主键只需要保留学生id即可</li></ul></li><li><strong>第三范式（3NF）</strong><ul><li>满足 2NF 前提下，非主属性必须互不依赖，消除传递依赖</li><li>假如员工表员工id为主键，员工id可以推出部门id，部门id又能推出部门名称，那么员工id推出部门名称这一关系就不能出现在同一张表中</li></ul></li></ul>
              </div>
            </details>

<h2 id="INT-n-中的n如何理解"><a href="#INT-n-中的n如何理解" class="headerlink" title="INT(n)中的n如何理解"></a>INT(n)中的n如何理解</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong><code>n</code> 是显示宽度</strong>，不是存储位数或范围</li><li>如果没有使用 <code>ZEROFILL</code>，<code>n</code> 的作用可以忽略</li><li><code>INT(n)</code> 的存储空间和范围与 <code>n</code> 无关</li></ul>
              </div>
            </details>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>原子性（Atomicity）</strong><ul><li>事务中的所有操作要么全部完成，要么全部不完成，不会结束在中间某个点。这意味着事务是一个不可分割的工作单元。</li></ul></li><li><strong>一致性（Consistency）</strong><ul><li>事务必须保证数据库从一个一致的状态转移到另一个一致的状态。事务执行的结果必须符合所有预定义的规则和约束。</li></ul></li><li><strong>隔离性（Isolation）</strong><ul><li>并发执行的事务之间不会互相影响。每个事务都像是在系统上独立运行，即使有多个事务同时进行，它们也应该是隔离的，以防止数据损坏。</li></ul></li><li><strong>持久性（Durability）</strong><ul><li>一旦事务提交，它对数据库的改变就是永久性的，即使系统发生故障，这些改变也不会丢失。</li></ul></li></ul>
              </div>
            </details>

<h2 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>脏读（Dirty Read）</strong><ul><li>一个事务读取了另一个事务未提交的数据。如果那个事务最终回滚了，那么读取的数据就是无效的。</li></ul></li><li><strong>不可重复读（Non-repeatable Read）</strong><ul><li>在一个事务中，多次读取同一数据集合时，由于其他事务的介入，可能会得到不同的结果。这种情况通常发生在读已提交或更低的隔离级别。</li></ul></li><li><strong>幻读（Phantom Read）</strong><ul><li>在同一事务中，当同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。</li></ul></li></ul>
              </div>
            </details>

<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>读未提交（Read Uncommitted）</strong><ul><li>事务可以读取到其他未提交事务的更改</li><li>可能导致脏读，即读取到其他事务未提交的数据</li></ul></li><li><strong>读已提交（Read Committed）</strong><ul><li>事务只能读取到其他事务已经提交的更改，避免了脏读</li><li>但可能遇到不可重复读的问题，即在同一事务中，由于其他事务的更新，两次读取到的数据不一致。</li></ul></li><li><strong>可重复读（Repeatable Read）</strong><ul><li>事务在整个过程中可以看到一致的快照数据，解决了不可重复读的问题</li><li>但是不能防止幻读，即在同一事务中，同一个查询在不同的时间产生不同的结果集</li></ul></li><li><strong>串行化（Serializable）</strong><ul><li>最高的隔离级别，通过完全串行化执行事务来避免脏读、不可重复读和幻读</li><li>在这个级别，事务将被序列化，依次单独执行，从而提供了最严格的隔离</li><li>但是这也可能导致较慢的性能</li></ul></li></ul><blockquote><p><em><strong>Tip</strong></em></p><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免了幻读现象</p><ul><li>针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题</li><li>针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题</li></ul><p>但是如果同时存在快照读和当前读，那么依然会存在幻读的问题</p></blockquote>
              </div>
            </details>

<h2 id="四种隔离级别是如何实现的"><a href="#四种隔离级别是如何实现的" class="headerlink" title="四种隔离级别是如何实现的"></a>四种隔离级别是如何实现的</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>读未提交</strong><ul><li>直接读取最新的数据</li></ul></li><li><strong>串行化</strong><ul><li>通过加读写锁的方式来避免并行访问</li></ul></li><li><strong>读已提交&amp;可重复读</strong><ul><li>它们是通过 Read View 来实现的，它们的区别在于<strong>创建 Read View 的时机不同</strong></li><li>读已提交是在<strong>每次读取数据时</strong>重新生成一个 Read View</li><li>可重复读是在<strong>启动事务时</strong>生成一个 Read View，然后整个事务期间都在用这个 Read View</li></ul></li></ul>
              </div>
            </details>

<h2 id="Read-View的实现原理"><a href="#Read-View的实现原理" class="headerlink" title="Read View的实现原理"></a>Read View的实现原理<a id="readview"></a></h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-second"><ul class="nav-tabs"><li class="tab active"><a class="#second-1">数据结构</a></li><li class="tab"><a class="#second-2">工作原理</a></li></ul><div class="tab-content"><div class="tab-pane active" id="second-1"><ul><li>Read View本质上是一个<strong>保存事务ID的列表</strong></li><li><strong>四个重要字段</strong><ul><li>m_ids：创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，「活跃事务」指的是启动了但还没提交的事务</li><li>min_trx_id：在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值</li><li>max_trx_id：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1</li><li>creator_trx_id ：指的是创建该 Read View 的事务的事务 id</li></ul></li><li><strong>两个隐藏字段</strong><ul><li>trx_id：当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里</li><li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo log中，这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录</li></ul></li></ul></div><div class="tab-pane" id="second-2"><ul><li>一个事务去访问记录时，自己的更新记录总是可见的</li><li>如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见</li><li>如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见</li><li>如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中<ul><li>如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。</li><li>如果记录的 trx_id 不在 m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见</li></ul></li></ul><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/read-view.png"
                      alt="read-view"
                ></p></div></div></div>
              </div>
            </details>

<h2 id="事务是如何实现的"><a href="#事务是如何实现的" class="headerlink" title="事务是如何实现的"></a>事务是如何实现的</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>实现事务就是要实现事务的<strong>四大特性ACID</strong><ul><li><a href="#undo">原子性通过undo log保证</a></li><li><a href="#redo">持久性通过redo log保证</a></li><li>隔离性通过锁和MVCC保证</li><li>一致性由原子性、持久性、隔离性共同保证</li></ul></li></ul>
              </div>
            </details>

<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="如何选择存储引擎"><a href="#如何选择存储引擎" class="headerlink" title="如何选择存储引擎"></a>如何选择存储引擎</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>InnoDB</strong><ul><li>需要事务（如支付系统）</li><li>高并发写入（如电商订单）</li><li>要求数据完整性和崩溃恢复</li></ul></li><li><strong>MyISAM</strong><ul><li>读多写少（如新闻网站的文章表）</li></ul></li><li><strong>MEMORY</strong><ul><li>临时数据或缓存（如会话存储）</li></ul></li></ul>
              </div>
            </details>

<h2 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a>InnoDB和MyISAM的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/mysql-innodb-vs-myisam.png"
                      alt="innodb-vs-myisam"
                ></p>
              </div>
            </details>

<h2 id="如何优化InnoDB的性能"><a href="#如何优化InnoDB的性能" class="headerlink" title="如何优化InnoDB的性能"></a>如何优化InnoDB的性能</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>调整缓冲池大小<ul><li>增加缓存以减少磁盘I&#x2F;O</li></ul></li><li>调整日志文件大小<ul><li>由于Redo Log采用WAL（Write-Ahead Logging）机制，先写日志再更新数据，日志文件大小决定了更新数据的频率</li></ul></li></ul>
              </div>
            </details>

<h2 id="为什么InnoDB在并发写入时性能更好"><a href="#为什么InnoDB在并发写入时性能更好" class="headerlink" title="为什么InnoDB在并发写入时性能更好"></a>为什么InnoDB在并发写入时性能更好</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>行级锁</strong><ul><li>仅锁定涉及的行，其他行仍可操作，减少锁冲突</li></ul></li><li><strong>MVCC（多版本并发控制）</strong><ul><li>通过版本链实现非阻塞读，读写操作互不阻塞</li></ul></li></ul>
              </div>
            </details>

<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p>数据结构上分为</p><ul><li>B+树索引</li><li>哈希索引</li></ul></li><li><p>物理结构上分为</p><ul><li>聚集索引</li><li>二级索引</li></ul></li><li><p>应用上分为：</p><ul><li>主键索引</li><li>普通索引</li><li>唯一索引</li><li>联合索引</li><li>全文索引</li></ul></li></ul>
              </div>
            </details>

<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><p>优点</p><ul><li>加快数据的检索速度</li><li>加快表和表之间的连接速度</li><li>可以显著减少查询中分组和排序的时间</li></ul></li><li><p>缺点</p><ul><li>创建和维护索引需要耗费时间，这种时间随着数据量的增加而增加，这样就降低了数据的维护速度</li><li>索引需要占物理空间，本质上是空间换时间</li></ul></li></ul>
              </div>
            </details>

<h2 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>什么时候需要创建索引<ul><li>对于很大的表且存在频繁用于查询条件的列，考虑建立索引提高查询速度</li><li>具有唯一性的数据可以创建索引，可以更快速的通过该索引来确定某条记录</li><li>频繁使用排序、分组和联合操作的列，执行这些操作时，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作</li></ul></li><li>什么时候不需要创建索引<ul><li>小表不建议索引，由于数据较小，直接查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果</li><li>经常进行更新的字段不需要创建索引，这样会破环B+树的结构，重新调整的开销大</li><li>字段中存在大量重复数据，不需要创建索引，比如性别字段</li></ul></li></ul>
              </div>
            </details>

<h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>数据存储位置</strong>：<ul><li><strong>B树</strong>：所有节点都存储数据，包括内部节点和叶子节点。</li><li><strong>B+树</strong>：仅叶子节点存储数据，内部节点只存储键值，用于索引。</li></ul></li><li><strong>叶子节点结构</strong>：<ul><li><strong>B树</strong>：叶子节点独立，不相互连接。</li><li><strong>B+树</strong>：叶子节点通过指针相连，形成有序链表，便于范围查询。</li></ul></li><li><strong>查询效率</strong>：<ul><li><strong>B树</strong>：由于数据分布在所有节点，查询时间不稳定，可能很快找到数据，也可能需要遍历多层。</li><li><strong>B+树</strong>：查询路径长度固定，必须到达叶子节点，因此查询时间更稳定。</li></ul></li></ul>
              </div>
            </details>

<h2 id="B-树为什么比B树更适合用与数据库索引"><a href="#B-树为什么比B树更适合用与数据库索引" class="headerlink" title="B+树为什么比B树更适合用与数据库索引"></a>B+树为什么比B树更适合用与数据库索引</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>B+ 树减少了 IO 次数</strong><ul><li>由于索引文件很大因此索引文件存储在磁盘上，B+ 树的非叶子结点只存关键字不存数据，因而单个页可以存储更多的关键字，即一次性读入内存的需要查找的关键字也就越多，磁盘的随机 I&#x2F;O 读取次数相对就减少了。</li></ul></li><li><strong>B+ 树查询效率更稳定</strong><ul><li>由于B+树数据只存在在叶子结点上，所以查找效率固定为 O(log n)，而B树的数据分布在所有节点，查询时间存在抖动，所以 B+ 树的查询效率相比B树更加稳定。</li></ul></li><li><strong>B+ 树更加适合范围查找</strong><ul><li>B+ 树叶子结点之间用链表有序连接，所以扫描全部数据只需扫描一遍叶子结点，利于扫库和范围查询；B 树由于非叶子结点也存数据，所以只能通过中序遍历按序来扫。也就是说，对于范围查询和有序遍历而言，B+ 树的效率更高。</li></ul></li></ul>
              </div>
            </details>

<h2 id="B-树相对于二叉树和Hash的优势"><a href="#B-树相对于二叉树和Hash的优势" class="headerlink" title="B+树相对于二叉树和Hash的优势"></a>B+树相对于二叉树和Hash的优势</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>相对于二叉树，B+树的层数更少，查询效率更高</li><li>相对于Hash，B+树支持范围匹配和排序操作</li></ul>
              </div>
            </details>

<h2 id="B-树查询数据的过程"><a href="#B-树查询数据的过程" class="headerlink" title="B+树查询数据的过程"></a>B+树查询数据的过程</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>定位根节点<ul><li>从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页</li></ul></li><li>内部节点遍历<ul><li>在内部节点中，继续定位到合适的子节点，并移动到该子节点，循环此过程直至到达叶子节点</li></ul></li><li>叶子节点遍历<ul><li>在叶子节点中，由于数据已排序，可以直接使用二分查找或顺序查找定位到具体的数据记录</li></ul></li></ul>
              </div>
            </details>

<h2 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>最左匹配原则主要用来处理使用联合索引时可能出现的一些问题</li><li>最左匹配原则要求查询条件中的列应该从索引的最左边的列开始，并且不能跳过中间的列</li><li>如果查询条件不按照索引的顺序进行匹配，那么索引可能会失效或者部分失效</li></ul>
              </div>
            </details>

<h2 id="回表查询和覆盖索引"><a href="#回表查询和覆盖索引" class="headerlink" title="回表查询和覆盖索引"></a>回表查询和覆盖索引</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>回表查询</strong><ul><li>因为二级索引只有索引和id字段的信息，如果要获取到其他字段，就需要通过id字段到聚簇索引中再次查询，这个过程就叫回表查询</li></ul></li><li><strong>覆盖索引</strong><ul><li>将select中的列包含在索引之中，这样在查找时就可以直接返回对应的字段信息，避免了回表查询</li></ul></li></ul>
              </div>
            </details>

<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>原理</strong><ul><li>对于较长的文本字段，直接对整个字段创建索引会占用大量存储空间，并且索引维护的开销较大。</li><li>前缀索引只对字段的前 <code>N</code> 个字符创建索引，从而减少索引大小，节省空间并提高查询效率。</li><li>例如，对 <code>desc VARCHAR(255)</code> 的字段，可以只对前 10 个字符创建索引<code>CREATE INDEX index_name ON table_name (desc(10))</code>。</li></ul></li><li><strong>注意事项</strong><ul><li><strong>区分度不足</strong>：如果前缀长度过短，可能导致大量重复值，降低查询效率。</li><li><strong>查询条件匹配</strong>：查询条件必须使用前缀匹配（如 <code>LIKE &#39;abc%&#39;</code>），否则无法利用前缀索引。</li><li><strong>排序和分组</strong>：前缀索引不支持 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。</li><li><strong>覆盖索引</strong>：前缀索引无法覆盖查询，因为只索引了部分字段。</li></ul></li></ul>
              </div>
            </details>

<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>在使用非主键索引进行查询时，如果索引列中存在某些判断条件时，会优先通过这些判断条件过滤掉不满足条件的数据，之后再进行回表操作进一步确定满足条件的数据</li><li>可以有效减少回表查询的次数，大大提升查询的效率</li></ul>
              </div>
            </details>

<h2 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>查询条件中有or时只要有一个条件没有索引，整个sql就不走索引</li><li>like查询是以%开头</li><li>字段类型不匹配时索引会失效</li><li>索引列参与计算会导致索引失效</li><li>违背最左匹配原则</li></ul>
              </div>
            </details>

<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>选择合适的索引类型和列</strong><ul><li>单列索引</li><li>复合索引</li><li>全文索引</li></ul></li><li><strong>避免索引失效和冗余</strong><ul><li>见索引失效的情况</li><li>删除重复或冗余的索引，如果已有索引 <code>(a, b)</code>，则索引 <code>(a)</code> 可能是冗余的</li></ul></li><li><strong>合理利用覆盖索引和前缀索引</strong><ul><li>见覆盖索引和前缀索引</li></ul></li></ul>
              </div>
            </details>

<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="MySQL锁的类型"><a href="#MySQL锁的类型" class="headerlink" title="MySQL锁的类型"></a>MySQL锁的类型</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-third"><ul class="nav-tabs"><li class="tab active"><a class="#third-1">全局锁</a></li><li class="tab"><a class="#third-2">表级锁</a></li><li class="tab"><a class="#third-3">行级锁</a></li></ul><div class="tab-content"><div class="tab-pane active" id="third-1"><ul><li><p><strong>作用</strong></p><ul><li>使<strong>整个数据库</strong>处于<strong>只读状态</strong></li></ul></li><li><p><strong>使用方法</strong></p><ul><li>开启全局锁：<code>flush tables with read lock</code></li><li>释放全局锁：<code>unlock tables</code></li></ul></li><li><p><strong>优缺点</strong></p><ul><li>开启全局锁后所有对数据的修改操作都不允许，保证了数据的一致性，适合做全库逻辑备份</li><li>全局锁开启期间，所有写操作都会被阻塞，容易导致业务停滞</li></ul></li></ul><blockquote><p><em><strong>Tip</strong></em></p><p>如果数据库的存储引擎支持事务的可重复读隔离级别，那么就可以避免全局锁导致的写操作阻塞，因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View</p></blockquote></div><div class="tab-pane" id="third-2"><ul><li><strong>表锁</strong><ul><li>锁定整张表</li><li>通过 <code>LOCK TABLES table_name READ/WRITE</code> 添加表级共享锁（读锁）&#x2F;独占锁（写锁）</li><li>读锁允许其他事务读取表，但阻止写操作；写锁阻止其他事务的读、写操作。</li></ul></li><li><strong>元数据锁</strong><ul><li><strong>保护表结构，防止在表结构变更时进行读写操作，反之亦然</strong></li><li>对数据库表进行操作时，会自动给这个表加上 MDL，在<strong>事务提交后才会释放</strong><ul><li>对一张表进行 CRUD 操作时，加的是 MDL 读锁</li><li>对一张表做结构变更操作的时候，加的是 MDL 写锁</li></ul></li></ul></li><li><strong>意向锁</strong><ul><li><strong>用来快速判断表里是否有记录被加锁</strong></li><li>也分为<strong>意向共享锁</strong>和<strong>意向独占锁</strong></li><li>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁<code>lock tables ... read</code>或独占表锁发<code>lock tables ... write</code>生冲突</li><li>因为在使用 InnoDB 引擎的表里对某些记录加上「共享锁&#x2F;独占锁」之前，需要先在表级别加上一个「意向共享锁&#x2F;意向独占锁」，那么再给表加「独占表锁」时，会先检查该表是否存在「意向共享锁&#x2F;意向独占锁」，如果有就意味着表里已经有记录被加了「共享锁&#x2F;独占锁」，这样就避免了加「独占表锁」时去遍历全部数据来判断表里是否有记录被加了锁</li></ul></li><li><strong>自增锁</strong><ul><li>保证被<code>AUTO_INCRMENT</code>修饰的字段是连续递增的</li><li>在插入数据时会加一个自增锁，插入操作执行完毕后立即释放，而不必等待整个事务提交才释放</li></ul></li></ul></div><div class="tab-pane" id="third-3"><ul><li><strong>记录锁</strong><ul><li>锁住的是一条记录</li></ul></li><li><strong>间隙锁</strong><ul><li>锁住的是两条记录之间的间隙，存在于RR隔离级别，防止其他事务在这个间隙进行INSERT操作，目的是为了解决幻读的现象</li></ul></li><li><strong>临键锁</strong><ul><li>锁住的是一个范围，并且包括记录本身（左闭右开区间），相当于记录锁+临键锁，存在于RR隔离级别，也是为了解决幻读的现象</li></ul></li><li><strong>插入意向锁</strong><ul><li><p>一种特殊的间隙锁，属于行级别锁</p><ul><li>假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁，当事务 A 还没提交的时候，事务 B 向该表插入一条 id &#x3D; 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态，此时事务 B 就会发生阻塞，直到事务 A 提交了事务</li><li>如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</li></ul></li><li><p>尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）</p></li></ul></li></ul></div></div></div>
              </div>
            </details>

<h2 id="MySQL是如何加行级锁的"><a href="#MySQL是如何加行级锁的" class="headerlink" title="MySQL是如何加行级锁的"></a>MySQL是如何加行级锁的</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>MySQL加锁的对象是索引，加锁的基本单位是「临键锁」</li><li>唯一索引加锁只加在唯一索引项上；非唯一索引加锁同时加在普通索引项和主键索引项上；不走索引会给所有记录加锁，相当于锁住全表</li><li>但是某些的场景下，「临键锁」会退化成「记录锁」或「间隙锁」</li></ul><div class="tabs" id="tab-fourth"><ul class="nav-tabs"><li class="tab active"><a class="#fourth-1">唯一索引</a></li><li class="tab"><a class="#fourth-2">非唯一索引</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fourth-1"><ul><li><strong>等值查询</strong><ul><li>当查询的记录是「存在」的，该记录索引的「临键锁」会退化成「记录锁」</li><li>当查询的记录是「不存在」的，先找到第一条大于该记录的记录，该记录索引的「临键锁」会退化成「间隙锁」</li></ul></li><li><strong>范围查询</strong><ul><li>针对「大于」或「大于等于」的范围查询<ul><li>如果边界记录不在表中<ul><li>不管是「大于」还是「大于等于」，会对每一个扫描到的索引项加「临键锁」</li></ul></li><li>如果边界记录存在于表中<ul><li>对于「大于」，依然对每一个扫描到的索引项加「临键锁」</li><li>对于「大于等于」，该边界记录索引的「临键锁」会退化成「记录锁」，其他扫描到的索引项加「临键锁」</li></ul></li></ul></li><li>针对「小于」或「小于等于」的范围查询<ul><li>如果边界记录不在表中<ul><li>不管是「小于」还是「小于等于」，先找到第一条大于该记录的记录，该记录索引的「临键锁」锁会退化成「间隙锁」，其他扫描到的索引项加「临键锁」</li></ul></li><li>如果边界记录存在于表中<ul><li>对于「小于」，边界记录索引的「临键锁」会退化成「间隙锁」，其他扫描到的索引项加「临键锁」</li><li>对于「小于等于」，直接对每一个扫描到的索引项加「临键锁」</li></ul></li></ul></li></ul></li></ul></div><div class="tab-pane" id="fourth-2"><ul><li><strong>等值查询</strong><ul><li>记录「存在」时，首先对该记录主键索引加「记录锁」，然后扫描寻找符合条件的记录，对这些记录的二级索引加「临键锁」，最后找到第一个不符合条件终止记录，对终止记录加「间隙锁」</li><li>记录「不存在」时，扫描找到第一个不符合条件终止记录，对该记录加「间隙锁」</li></ul></li><li><strong>范围查询</strong><ul><li>对所有扫描到的索引项，不管是主键索引还是二级索引，都加「临键锁」，不存在「临键锁」退化的情况</li></ul></li></ul></div></div></div>
              </div>
            </details>

<h2 id="MySQL死锁"><a href="#MySQL死锁" class="headerlink" title="MySQL死锁"></a>MySQL死锁</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>死锁是指在两个或多个事务在执行过程中，因争夺资源而互相等待的现象。简单来说，就是事务A等待事务B释放资源，而事务B又在等待事务A释放资源，最终导致双方都无法完成。</li><li><strong>解决死锁的方法</strong><ul><li>设置事务等待锁的超时时间。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。</li><li>开启主动死锁检测。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。</li></ul></li></ul>
              </div>
            </details>

<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-fifth"><ul class="nav-tabs"><li class="tab active"><a class="#fifth-1">乐观锁</a></li><li class="tab"><a class="#fifth-2">悲观锁</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fifth-1"><ul><li><strong>原理</strong><ul><li>乐观锁假设数据冲突较少，所以在读取数据时不会加锁，而是在更新数据时通过版本号或时间戳来检测数据是否被其他事务修改，常见的实现方式是在数据表中增加一个版本号（version）字段，更新时同时检查版本号是否与之前读取的一致，如果受影响的行数为0，则说明数据在此期间被其他事务修改，更新操作就会失败，应用程序可以选择重新读取数据并重试。</li></ul></li><li><strong>特点</strong><ul><li><strong>高并发性能</strong>：读操作时无需加锁，降低了锁竞争，适合高并发场景。</li><li><strong>冲突检测</strong>：通过版本号等机制在更新时检测数据冲突，确保数据一致性。</li><li><strong>冲突处理</strong>：当冲突发生时需要应用程序层面处理，比如重试或报错，业务逻辑可能因此复杂化。</li></ul></li><li><strong>适用场景</strong><ul><li>系统读多写少的场景或者并发冲突较少的应用。</li><li>业务场景允许在冲突发生时进行重试或补救措施。</li></ul></li></ul></div><div class="tab-pane" id="fifth-2"><ul><li><strong>原理</strong><ul><li>悲观锁假设数据竞争会频繁发生，因此在每次操作数据时都会先对数据进行加锁。比如在使用InnoDB存储引擎时，可以通过 <code>SELECT ... FOR UPDATE</code> 对查询到的记录加排他锁，从而防止其他事务对这些记录进行修改。</li></ul></li><li><strong>特点</strong><ul><li><strong>严格控制并发</strong>：在加锁期间，其他事务无法修改甚至读取被锁定的数据（根据锁类型不同，可能允许读操作，但通常都是锁住写操作）。</li><li><strong>数据安全性高</strong>：适合在竞争激烈、数据一致性要求高的场景下使用。</li><li><strong>性能开销</strong>：由于需要频繁加锁和解锁，且锁会导致事务等待，可能降低并发性能。</li></ul></li><li><strong>适用场景</strong><ul><li>写操作频繁且冲突可能性较高的系统。</li><li>对数据一致性要求非常严格、容忍较低并发的业务场景。</li></ul></li></ul></div></div></div>
              </div>
            </details>

<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="MySQL中常见的日志"><a href="#MySQL中常见的日志" class="headerlink" title="MySQL中常见的日志"></a>MySQL中常见的日志</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>回滚日志（Undo Log）</strong>： 保存了事务发生之前的数据的一个版本，作用是通过回滚<strong>保证事务的原子性</strong>和<strong>配合Read View实现MVCC</strong>。</li><li><strong>重做日志（Redo Log）：</strong>：记录了事务执行后的状态，用来恢复未写入 data file 的已提交事务数据，作用是用于掉电等故障的恢复，以<strong>确保事务的持久性</strong>。</li><li><strong>二进制日志（Bin Log）</strong>：Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li><li><strong>普通查询日志（General Query Log）</strong>：记录了服务器接收到的每一个命令，无论命令语句是否正确，因此会带来不小开销，所以也是默认关闭的。</li><li><strong>慢查询日志（Slow Query Log）</strong>：记录执行时间过长和没有使用索引的查询语句（默认 10s），同时<strong>只会记录执行成功的语句</strong>。</li></ul>
              </div>
            </details>

<h2 id="Undo-Log如何保证事务的原子性"><a href="#Undo-Log如何保证事务的原子性" class="headerlink" title="Undo Log如何保证事务的原子性"></a>Undo Log如何保证事务的原子性<a id="undo"></a></h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：<ul><li>插入一条记录时，要把这条记录的主键值记下来，回滚时只需要把这个主键值对应的记录删掉即可</li><li>删除一条记录时，要把这条记录中的内容都记下来，回滚时把由这些内容组成的记录插入到表中</li><li>更新一条记录时，要把被更新的列的旧值记下来，回滚时把这些列更新为旧值</li></ul></li></ul>
              </div>
            </details>

<h2 id="Redo-Log如何保证事务的持久性"><a href="#Redo-Log如何保证事务的持久性" class="headerlink" title="Redo Log如何保证事务的持久性"></a>Redo Log如何保证事务的持久性<a id="redo"></a></h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>InnoDB 使用了一种叫做 <strong>Write-Ahead Logging (WAL)</strong> 的技术，Redo Log 是 WAL 的具体实现。</li><li><strong>工作原理</strong><ul><li><strong>事务执行时</strong>：<ul><li>当事务修改数据时，InnoDB 首先将修改操作记录到内存中的 <strong>Buffer Pool</strong>（缓冲池），而不是直接写到磁盘上的数据文件。</li><li>同时，这些修改会被记录到 <strong>Redo Log Buffer</strong>（重做日志缓冲区）中。</li></ul></li><li><strong>事务提交时</strong>：<ul><li>Redo Log Buffer 中的日志会被写入磁盘上的 <strong>Redo Log 文件</strong>（通常是 ib_logfile0 和 ib_logfile1）。</li><li>只有当 Redo Log 成功写入磁盘后，事务才算真正提交成功。</li><li>数据文件的实际修改（脏页刷新）可以延迟进行，由后台线程异步完成。</li></ul></li><li><strong>崩溃恢复时</strong>：<ul><li>如果系统在事务提交后但数据文件未更新前崩溃，InnoDB 会利用磁盘上的 Redo Log 重放已提交事务的修改，恢复数据到一致状态。</li></ul></li></ul></li></ul>
              </div>
            </details>

<h2 id="脏页什么时候刷盘"><a href="#脏页什么时候刷盘" class="headerlink" title="脏页什么时候刷盘"></a>脏页什么时候刷盘</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘</li><li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘</li><li>MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘</li><li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘</li></ul>
              </div>
            </details>

<h2 id="Redo-Log什么时候刷盘"><a href="#Redo-Log什么时候刷盘" class="headerlink" title="Redo Log什么时候刷盘"></a>Redo Log什么时候刷盘</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>MySQL正常关闭时</li><li>Redo Log Buffer空间不足时</li><li>后台线程定期异步刷新</li><li>事务提交时（由 innodb_flush_log_at_trx_commit 参数控制，默认为1）<ul><li>参数为0时，不主动触发刷盘</li><li>参数为1时，每次事务提交时，Redo Log Buffer 中的日志立即写入磁盘</li><li>参数为2时，每次事务提交时，日志写入操作系统缓存，转由操作系统控制落盘时机</li></ul></li></ul>
              </div>
            </details>

<h2 id="Redo-Log和Bin-Log有什么不同"><a href="#Redo-Log和Bin-Log有什么不同" class="headerlink" title="Redo Log和Bin Log有什么不同"></a>Redo Log和Bin Log有什么不同</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>适用对象不同</strong><ul><li>Bin Log 是 MySQL的 Server 层实现的，所有存储引擎都可以使用</li><li>Redo Log 是lnnodb 存储引擎实现的日志</li></ul></li><li><strong>文件格式不同</strong><ul><li>Redo Log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</li><li>Bin Log有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED<ul><li>STATEMENT：每一条修改数据的 SQL 都会被记录到 Bin Log 中（相当于记录了逻辑操作，所以针对这种格式， Bin Log 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如用了 uuid 或者 now 这些函数，在主库上执行的结果和在从库执行的结果不一致，这种随时在变的函数会导致复制的数据不一致</li><li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已</li><li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式</li></ul></li></ul></li><li><strong>写入方式不同</strong><ul><li>Bin Log 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志</li><li>Redo Log是循环写，日志空间大小固定，全部写满就从头开始</li></ul></li><li><strong>用途不同</strong><ul><li>Bin Log 用于备份恢复、主从复制</li><li>Redo Log 用于故障后的数据恢复</li></ul></li></ul>
              </div>
            </details>

<h2 id="Bin-Log什么时候刷盘"><a href="#Bin-Log什么时候刷盘" class="headerlink" title="Bin Log什么时候刷盘"></a>Bin Log什么时候刷盘</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <p>MySQL提供一个 sync_binlog 参数来控制数据库的 Bin Log 刷到磁盘上的频率</p><ul><li>sync_binlog &#x3D; 0 的时候，每次提交事务都只写入到操作系统缓存，后续交由操作系统决定何时将数据持久化到磁盘</li><li>sync_binlog &#x3D; 1 的时候，每次提交事务都会马上执行刷盘</li><li>sync_binlog &#x3D;N（N&gt;1） 的时候，累积 N 个事务后一起刷盘</li></ul>
              </div>
            </details>

<h2 id="两段提交"><a href="#两段提交" class="headerlink" title="两段提交"></a>两段提交</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>事务提交后，Redo Log 和 Bin Log 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致，在主从架构中，两者无论是哪一个单独成功，最终都会导致主从不一致的问题，「两段提交」就是为应对该问题的解决方案，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</li><li><strong>两段提交过程</strong><ul><li>Prepare阶段<ul><li>将 XID写入到 Redo Log，同时将 Redo Log 对应的事务状态设置为 prepare，然后将 Redo Log持久化到磁盘</li></ul></li><li>Commit阶段<ul><li>把 XID 写入到 Bin Log，然后将 Bin Log 持久化到磁盘，接着调用引擎的提交事务接口，将 Redo Log 状态设置为 commit</li></ul></li></ul></li><li>两段提交的核心点就是将Redo Log的写入拆分成两个阶段，以此确保确保 Redo Log 和 Bin Log 之间的顺序和一致性</li><li><strong>两段提交的问题</strong><ul><li>磁盘IO次数高：每次事务提交都要进行两次刷盘，一次是 redo log 刷盘，另一次是 binlog 刷盘</li><li>锁竞争激烈：在多事务的场景下，需要通过加锁来确保两个事务提交顺序一致</li></ul></li></ul>
              </div>
            </details>

<h1 id="进阶部分"><a href="#进阶部分" class="headerlink" title="进阶部分"></a>进阶部分</h1><h2 id="MySQL逻辑框架"><a href="#MySQL逻辑框架" class="headerlink" title="MySQL逻辑框架"></a>MySQL逻辑框架</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/post/mysql-framework.png"
                      alt="mysql-framework"
                ></p>
              </div>
            </details>

<h2 id="一条SQL语句的总体流程"><a href="#一条SQL语句的总体流程" class="headerlink" title="一条SQL语句的总体流程"></a>一条SQL语句的总体流程</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ol><li>**连接器：**建立连接，管理连接、校验用户身份</li><li>**查询缓存：**查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块</li><li>**分析器：**通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型</li><li>**优化器：**决定使用哪个索引，或者在一个语句有多表关联（join）时，决定各个表的连接顺序，生成执行成本最小的执行计划</li><li>**执行器：**根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端</li></ol>
              </div>
            </details>

<h2 id="一条Update语句的具体执行流程"><a href="#一条Update语句的具体执行流程" class="headerlink" title="一条Update语句的具体执行流程"></a>一条Update语句的具体执行流程</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ol start="0"><li>连接器、分析器、优化器</li><li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取要更新的记录<ul><li>如果记录所在的数据页就在 buffer pool 中，直接返回给执行器更新</li><li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器</li></ul></li><li>执行器得到聚簇索引记录后，会检查更新前的记录和更新后的记录是否一样<ul><li>如果一样的话就不进行后续更新流程</li><li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作</li></ul></li><li>开启事务， InnoDB 层更新记录前，首先需要把被更新的列的旧值记下来，生成一条 Undo Log，Undo Log 会写入 Buffer Pool 中的 Undo 页面</li><li>InnoDB在Buffer Pool中更新对应的数据页，并将该数据页标记为脏页，然后通过WAL技术，先写Redo Log，之后在合适的时机将脏页持久化到磁盘</li><li>然后开始记录该语句对应的Bin Log，也在合适的时机刷盘，默认是在事务提交时刷盘</li><li>事务提交阶段，两段提交</li><li>至此完成一条更新语句</li></ol>
              </div>
            </details>

<h2 id="MVCC是什么"><a href="#MVCC是什么" class="headerlink" title="MVCC是什么"></a>MVCC是什么</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>MVCC（Multi-Version Concurrency Control，多版本并发控制）是MySQL InnoDB 存储引擎用来提高并发性能并减少事务锁竞争的一种机制，它允许数据库同时存在多个版本的数据，实现读写不冲突，从而提升性能</li><li>主要通过Undo Log和<a href="#readview">Read View</a>来实现</li></ul>
              </div>
            </details>

<h2 id="SQL调优"><a href="#SQL调优" class="headerlink" title="SQL调优"></a>SQL调优</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>计数时尽量使用COUNT(1)或COUNT(*)</li><li>查询时尽量使用SELECT(明确字段)<ul><li>优化器解析<code>*</code>符号为所有列名要耗费时间，并且<code>*</code>号无法使用覆盖索引</li></ul></li><li>使用limit N，少用limit M，N，避免深度分页</li><li>尽量UNION ALL而不是UNION<ul><li>UNION ALL不去重，速度更快</li></ul></li></ul>
              </div>
            </details>

<h2 id="查询速度慢如何分析"><a href="#查询速度慢如何分析" class="headerlink" title="查询速度慢如何分析"></a>查询速度慢如何分析</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>分析查询语句</strong><ul><li>使用EXPLAIN命令分析SQL执行计划，找出慢查询的原因，比如是否使用了全表扫描，是否存在索引未被利用的情况等，并根据相应情况对索引进行适当修改。</li></ul></li><li>SQL<strong>优化角度</strong><ul><li><a href="#SQL%E8%B0%83%E4%BC%98">SQL调优</a></li></ul></li><li><strong>索引优化角度</strong><ul><li>创建或优化索引：根据查询条件创建合适的索引，特别是经常用于WHERE子句的字段、Orderby 排序的字段、Join 连表查询的字典、 group by的字段，并且如果查询中经常涉及多个字段，考虑创建联合索引，使用联合索引要符合最左匹配原则，不然会索引失效</li><li>避免索引失效：比如不要用左模糊匹配、函数计算、表达式计算等等。</li></ul></li><li><strong>数据库优化角度</strong><ul><li>优化数据库表<ul><li>如果单表的数据超过了千万级别，考虑是否需要将大表拆分为小表，减轻单个表的查询压力。</li><li>也可以将字段多的表分解成多个表，有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开。</li></ul></li><li>使用缓存技术<ul><li>引入缓存层，如Redis，存储热点数据和频繁查询的结果，但是要考虑缓存一致性的问题，对于读请求会选择旁路缓存策略，对于写请求会选择先更新 db，再删除缓存的策略。</li></ul></li></ul></li></ul>
              </div>
            </details>

<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li>主从复制主要实现数据的备份、读写分离功能，主库负责写，从库负责读</li><li><strong>主从复制的原理</strong><ul><li>首先主库将表的变更写入binlog日志</li><li>然后从库连接到主库，通过IO线程将主库binlog日志拷贝到本地，写入到中继日志中</li><li>从库有一个sql线程会从中继日志读取binlog日志，相当于在本地再执行一遍SQL</li></ul></li><li><strong>主从复制的同步方式</strong><ul><li>同步复制<ul><li>MySQL 主库提交事务的线程等待所有从库的复制成功响应，才返回客户端结果</li><li>一般不使用这种方式，因为性能和可用性都比较差</li></ul></li><li>异步复制（默认）<ul><li>MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。</li><li>这种模式一旦主库宕机，数据就会发生丢失。</li></ul></li><li>半同步复制<ul><li>MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行</li><li>这种半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</li></ul></li></ul></li></ul>
              </div>
            </details>

<h2 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <div class="tabs" id="tab-sixth"><ul class="nav-tabs"><li class="tab active"><a class="#sixth-1">分库</a></li><li class="tab"><a class="#sixth-2">分表</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sixth-1"><ul><li>为什么要分库<ul><li>磁盘容量有限</li><li>数据库的连接数有限，高并发场景下，会出现too many connections报错</li></ul></li><li>分库的好处<ul><li>解决了单库大数据，高并发的性能瓶颈</li><li>可以降低单机硬件资源的瓶颈</li></ul></li><li>分库的方式<ul><li>水平分库<ul><li>把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上</li></ul></li><li>垂直分库<ul><li>将表按业务分类，然后分布在不同数据库，部署在不同服务器上</li></ul></li></ul></li></ul></div><div class="tab-pane" id="sixth-2"><ul><li>为什么要分表<ul><li>单表数据量太大，做了很多优化仍然无法提升效率</li><li>索引一般是B+树存储结构，B+树高度增高，查询会过慢</li></ul></li><li>分表的好处<ul><li>优化单一表数据量过大而产生的性能问题</li><li>避免IO争抢并减少锁表的几率</li></ul></li><li>分表的方式<ul><li>水平分表<ul><li>在同一个数据库内，把同一个表的数据按一定规则拆到多个表中</li></ul></li><li>垂直分表<ul><li>将一个表按照字段分成多表，每个表存储其中一部分字段</li></ul></li></ul></li></ul></div></div></div>
              </div>
            </details>

<h2 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h2><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Answer </summary>
              <div class='content'>
              <ul><li><strong>事务一致性问题</strong><ul><li>由于分库分表把数据分布在不同库甚至不同服务器，不可避免会带来分布式事务问题。</li></ul></li><li><strong>跨节点关联查询</strong><ul><li>垂直分库后两张表的信息不在一个数据库，甚至不在一台服务器，也无法进行关联查询</li><li>可将原关联查询分为两次查询，第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据，最后将获得到的数据进行拼装</li></ul></li><li><strong>跨节点分页排序</strong><ul><li>跨节点多库进行查询时，limit分页、order by排序等问题，就变得比较复杂了，需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序</li></ul></li><li><strong>主键避重</strong><ul><li>在分库分表环境中，由于表中数据同时存在不同数据库中，主键值使用的自增长将无法使用，某个分区数据库生成的ID无法保证全局唯一，因此需要单独设计全局主键，以避免跨库主键重复问题</li></ul></li></ul>
              </div>
            </details>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
</search>
